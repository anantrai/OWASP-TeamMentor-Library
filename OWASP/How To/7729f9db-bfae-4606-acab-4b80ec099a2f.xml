<?xml version="1.0" encoding="utf-8"?><guidanceItem id="7729f9db-bfae-4606-acab-4b80ec099a2f" type="howto" title="How to Prevent Cross-Site Scripting in ASP.NET" cssFile="guidance.css" Date="2010-06-29T22:46:39.1762464Z" Author="" Category="Input and Data Validation" filePath="..\Libraries\OWASP\How To\7729f9db-bfae-4606-acab-4b80ec099a2f.xml" Priority="" Rule_Type="Implementation" Source="SI" Status="" Technology="ASP.NET 3.5" Topic="Security" Type="How To" xmlns="urn:microsoft:guidanceexplorer:guidanceItem"><content><![CDATA[<H1>Summary</H1><P>This How to shows how you can help protect your ASP.NET applications from cross-site scripting attacks by using proper input validation techniques and by encoding the output. It also describes a number of other protection mechanisms that you can use in addition to these two main countermeasures.</P><P>Cross-site scripting (XSS) attacks exploit vulnerabilities in Web page validation by injecting client-side script code. Common vulnerabilities that make your Web applications susceptible to cross-site scripting attacks include failing to properly validate input, failing to encode output, and trusting the data retrieved from a shared database. To protect your application against cross-site scripting attacks, assume that all input is malicious. Constrain and validate all input. Encode all output that could, potentially, include HTML characters. This includes data read from files and databases.</P><H1>Contents</H1><UL><LI><DIV>Objectives</DIV><LI><DIV>Overview</DIV><LI><DIV>Summary of Steps</DIV><LI><DIV>Step 1. Check That ASP.NET Request Validation Is Enabled</DIV><LI><DIV>Step 2. Review ASP.NET Code That Generates HTML Output</DIV><LI><DIV>Step 3. Determine Whether HTML Output Includes Input Parameters</DIV><LI><DIV>Step 4. Review Potentially Dangerous HTML Tags and Attributes</DIV><LI><DIV>Step 5. Evaluate Countermeasures</DIV><LI><DIV>Additional Considerations</DIV><LI><DIV>Additional Resources</DIV></LI></UL><H1>Objectives</H1><UL><LI>Understand the common cross-site scripting vulnerabilities in Web page validation. <LI>Apply countermeasures for cross-site scripting attacks. <LI>Constrain input by using regular expressions, type checks, and ASP.NET validator controls. <LI>Constrain output to ensure the browser does not execute HTML tags that contain script code. <LI>Review potentially dangerous HTML tags and attributes and evaluate countermeasures. </LI></UL><H1>Overview</H1><P>Cross-site scripting attacks exploit vulnerabilities in Web page validation by injecting client-side script code. The script code embeds itself in response data, which is sent back to an unsuspecting user. The user's browser then runs the script code. Because the browser downloads the script code from a trusted site, the browser has no way of recognizing that the code is not legitimate, and Microsoft Internet Explorer security zones provide no defense. Cross-site scripting attacks also work over HTTP and HTTPS (SSL) connections. </P><P>One of the most serious examples of a cross-site scripting attack occurs when an attacker writes script to retrieve the authentication cookie that provides access to a trusted site and then posts the cookie to a Web address known to the attacker. This enables the attacker to spoof the legitimate user's identity and gain illicit access to the Web site.</P><P>Common vulnerabilities that make your Web application susceptible to cross-site scripting attacks include: </P><UL><LI>Failing to constrain and validate input. <LI>Failing to encode output. <LI>Trusting data retrieved from a shared database. </LI></UL><H2>Guidelines</H2><P>The two most important countermeasures to prevent cross-site scripting attacks are to: </P><UL><LI><B>Constrain input</B>.<B> </B><LI><B>Encode output</B>. </LI></UL><H3>Constrain Input</H3><P>Start by assuming that all input is malicious. Validate input type, length, format, and range. </P><UL><LI>To constrain input supplied through server controls, use ASP.NET validator controls such as <B>RegularExpressionValidator</B> and <B>RangeValidator</B>. <LI>To constrain input supplied through client-side HTML input controls or input from other sources such as query strings or cookies, use the <B>System.Text.RegularExpressions.Regex</B> class in your server-side code to check for expected using regular expressions. <LI>To validate types such as integers, doubles, dates, and currency amounts, convert the input data to the equivalent .NET Framework data type and handle any resulting conversion errors. </LI></UL><H3>Encode Output</H3><P>Use the <B>AntiXSSLibrary.HtmlEncode</B> method to encode output if it contains input from the user or from other sources such as databases. <B>HtmlEncode</B> replaces characters that have special meaning in HTML-to-HTML variables that represent those characters. For example, &lt; is replaced with <B>&amp;lt;</B> and <B>"</B> is replaced with <B>&amp;quot;</B>. Encoded data does not cause the browser to execute code. Instead, the data is rendered as harmless HTML.</P><P>Similarly, use <STRONG>AntiXSSLibrary.UrlEncode</STRONG> to encode output URLs if they are constructed from input.</P><H1>Summary of Steps</H1><P>To prevent cross-site scripting, perform the following steps: </P><UL><LI>Step 1. Check that ASP.NET request validation is enabled. <LI>Step 2. Review ASP.NET code that generates HTML output. <LI>Step 3. Determine whether HTML output includes input parameters. <LI>Step 4. Review potentially dangerous HTML tags and attributes. <LI>Step 5. Evaluate countermeasures. </LI></UL><H1>Step 1. Check That ASP.NET Request Validation Is Enabled</H1><P>By default, request validation is enabled in Machine.config. Verify that request validation is currently enabled in your server's Machine.config file and that your application does not override this setting in its Web.config file. Check that <B>validateRequest</B> is set to <B>true </B>as shown in the following code example.</P><DIV><PRE>&lt;system.web&gt;<BR>&nbsp; &lt;pages buffer="true" validateRequest="true" /&gt;<BR>&lt;/system.web&gt;  </PRE></DIV><P>You can disable request validation on a page-by-page basis. Check that your pages do not disable this feature unless necessary. For example, you may need to disable this feature for a page if it contains a free-format, rich-text entry field designed to accept a range of HTML characters as input. </P><H2>To test that ASP.NET request validation is enabled </H2><OL><LI>Create an ASP.NET page that disables request validation. To do this, set <B>ValidateRequest="false"</B>, as shown in the following code example. <DIV><PRE>&lt;&#37;&#64; Page Language="C#" ValidateRequest="false" &#37;&gt;<BR>&lt;html&gt;<BR>&nbsp;&lt;script runat="server"&gt;<BR>&nbsp; void btnSubmit_Click(Object sender, EventArgs e)<BR>&nbsp; &#123;<BR>&nbsp;&nbsp;&nbsp; // If ValidateRequest is false, then 'hello' is displayed<BR>&nbsp;&nbsp;&nbsp; // If ValidateRequest is true, then ASP.NET returns an exception<BR>&nbsp;&nbsp;&nbsp; Response.Write(txtString.Text);<BR>&nbsp; &#125;<BR>&nbsp;&lt;/script&gt;<BR>&nbsp;&lt;body&gt;<BR>&nbsp; &lt;form id="form1" runat="server"&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;asp:TextBox id="txtString" runat="server" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text="&lt;script&gt;alert('hello');&lt;/script&gt;" /&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;asp:Button id="btnSubmit" runat="server"&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnClick="btnSubmit_Click" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text="Submit" /&gt;<BR>&nbsp; &lt;/form&gt;<BR>&nbsp;&lt;/body&gt;<BR>&lt;/html&gt;  </PRE></DIV><LI>Run the page. It displays <B>Hello</B> in a message box because the script in <B>txtString</B> is passed through and rendered as client-side script in your browser. <LI>Set <B>ValidateRequest="true"</B> or remove the <B>ValidateRequest</B> page attribute and browse to the page again. Verify that the following error message is displayed. <DIV><PRE>A potentially dangerous Request.Form value was detected from the client (txtString="&lt;script&gt;alert('hello...").  </PRE></DIV><P>This indicates that ASP.NET request validation is active and has rejected the input because it includes potentially dangerous HTML characters. </P><BLOCKQUOTE><B>Note</B>&nbsp;&nbsp;&nbsp;Do not rely on ASP.NET request validation. Treat it as an extra precautionary measure in addition to your own input validation.</BLOCKQUOTE></LI></OL><H1><BR>Step 2. Review ASP.NET Code That Generates HTML Output</H1><P>ASP.NET writes HTML as output in two ways, as shown in the following code examples.</P><DIV><PRE>Response.Write<BR>&lt;&#37; = </PRE></DIV><P>Search your pages to locate where HTML and URL output is returned to the client.</P><H1>Step 3. Determine Whether HTML Output Includes Input Parameters</H1><P>Analyze your design and your page code to determine whether the output includes any input parameters. These parameters can come from a variety of sources. The following list includes common input sources: </P><UL><LI><B>Form fields</B>, such as the following. <DIV><PRE>Response.Write(name.Text);<BR>Response.Write(Request.Form&#91;"name"&#93;);<BR>Query Strings<BR>Response.Write(Request.QueryString&#91;"name"&#93;);  </PRE></DIV><LI><B>Query strings</B>, such as the following: <DIV><PRE>Response.Write(Request.QueryString&#91;"username"&#93;);  </PRE></DIV><LI><B>Databases and data access methods</B>, such as the following: <DIV><PRE>SqlDataReader reader = cmd.ExecuteReader();<BR>Response.Write(reader.GetString(1));  </PRE></DIV><P>Be particularly careful with data read from a database if it is shared by other applications. </P><LI><B>Cookie collection</B>, such as the following: <DIV><PRE>Response.Write(<BR>Request.Cookies&#91;"name"&#93;.Values&#91;"name"&#93;);  </PRE></DIV><LI><B>Session and application variables</B>, such as the following: <DIV><PRE>Response.Write(Session&#91;"name"&#93;);<BR>Response.Write(Application&#91;"name"&#93;);  </PRE></DIV></LI></UL><P>In addition to source code analysis, you can also perform a simple test by typing text such as "<B>XYZ</B>" in form fields and testing the output. If the browser displays "<B>XYZ</B>" or if you see "<B>XYZ</B>" when you view the source of the HTML, your Web application is vulnerable to cross-site scripting. </P><P>To see something more dynamic, inject &lt;<B>script</B>&gt;<B>alert('hello');</B>&lt;<B>/script</B>&gt; through an input field. This technique might not work in all cases because it depends on how the input is used to generate the output.</P><H1>Step 4. Review Potentially Dangerous HTML Tags and Attributes</H1><P>If you dynamically create HTML tags and construct tag attributes with potentially unsafe input, make sure you HTML-encode the tag attributes before writing them out. </P><P>The following .aspx page shows how you can write HTML directly to the return page by using the &lt;<B>asp:Literal</B>&gt; control. The code takes user input of a color name, inserts it into the HTML sent back, and displays text in the color entered. The page uses <B>HtmlEncode</B> to ensure the inserted text is safe.</P><DIV><PRE>&lt;&#37;&#64; Page Language="C#" AutoEventWireup="true"&#37;&gt;</PRE><PRE>&lt;html&gt;<BR>&nbsp; &lt;form id="form1" runat="server"&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;div&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color:&amp;nbsp;&lt;asp:TextBox ID="TextBox1" runat="server"&gt;&lt;/asp:TextBox&gt;&lt;br /&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Button ID="Button1" runat="server" Text="Show color" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnClick="Button1_Click" /&gt;&lt;br /&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Literal ID="Literal1" runat="server"&gt;&lt;/asp:Literal&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;/div&gt;<BR>&nbsp; &lt;/form&gt;<BR>&lt;/html&gt;</PRE></DIV><PRE>&lt;script runat="server"&gt;<BR>&nbsp; private void Page_Load(Object Src, EventArgs e)<BR>&nbsp; &#123;<BR>&nbsp;&nbsp;&nbsp; protected void Button1_Click(object sender, EventArgs e)<BR>&nbsp;&nbsp;&nbsp; &#123;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Literal1.Text = &#64;"&lt;span style=""color:" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#43; Server.HtmlEncode(TextBox1.Text)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#43; &#64;"""&gt;Color example&lt;/span&gt;";<BR>&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp; &#125;<BR>&lt;/Script&gt;</PRE><H2>Potentially Dangerous HTML Tags</H2><P>While not an exhaustive list, the following commonly used HTML tags could allow a malicious user to inject script code: </P><UL><LI>&lt;<B>applet</B>&gt; <LI>&lt;<B>body</B>&gt; <LI>&lt;<B>embed</B>&gt; <LI>&lt;<B>frame</B>&gt; <LI>&lt;<B>script</B>&gt; <LI>&lt;<B>frameset</B>&gt; <LI>&lt;<B>html</B>&gt; <LI>&lt;<B>iframe</B>&gt; <LI>&lt;<B>img</B>&gt; <LI>&lt;<B>style</B>&gt; <LI>&lt;<B>layer</B>&gt; <LI>&lt;<B>link</B>&gt; <LI>&lt;<B>ilayer</B>&gt; <LI>&lt;<B>meta</B>&gt; <LI>&lt;<B>object</B>&gt; </LI></UL><P>An attacker can use HTML attributes such as <B>src</B>, <B>lowsrc</B>, <B>style</B>, and <B>href</B> in conjunction with the preceding tags to inject cross-site scripting. For example, the <B>src</B> attribute of the &lt;<B>img</B>&gt; tag can be a source of injection, as shown in the following examples.</P><DIV><PRE>&lt;img src="javascript:alert('hello');"&gt;<BR>&lt;img src="java&amp;#010;script:alert('hello');"&gt;<BR>&lt;img src="java&amp;#X0A;script:alert('hello');"&gt;  </PRE></DIV><P>An attacker can also use the &lt;<B>style</B>&gt; tag to inject a script by changing the MIME type as shown in the following.</P><DIV><PRE>&lt;style TYPE="text/javascript"&gt;<BR>&nbsp; alert('hello');<BR>&lt;/style&gt;  </PRE></DIV><H1>Step 5. Evaluate Countermeasures</H1><P>When you find ASP.NET code that generates HTML using some input, you need to evaluate appropriate countermeasures for your specific application. Countermeasures include: </P><UL><LI>Encode HTML output. <LI>Encode URL output. <LI>Filter user input. </LI></UL><H2>Encode HTML Output</H2><P>If you write text output to a Web page and you do not know if the text contains HTML special characters (such as &lt;, &gt;, and <B>&amp;</B>), pre-process the text by using the <B>AntiXSSLibrary.HtmlEncode</B> method as shown in the following code example. Do this if the text came from user input, a database, or a local file.</P><DIV><PRE>Response.Write(AntiXSSLibrary.HtmlEncode(Request.Form&#91;"name"&#93;));  </PRE></DIV><P>Do not substitute encoding output for checking that input is well-formed and correct. Use it as an additional security precaution.</P><H2>Encode URL Output</H2><P>If you return URL strings that contain input to the client, use the <B>AntiXSSLibrary.UrlEncode</B> method to encode these URL strings as shown in the following code example.</P><DIV><PRE>Response.Write(AntiXSSLibrary.UrlEncode(urlString));  </PRE></DIV><H2>Filter User Input</H2><P>If you have pages that need to accept a range of HTML elements, for example through some kind of rich text input field, you must disable ASP.NET request validation for the page. If you have several pages that do this, create a filter that allows only the HTML elements that you want to accept. A common practice is to restrict formatting to safe HTML elements such as bold (&lt;<B>b</B>&gt;) and italic (&lt;<B>i</B>&gt;).</P><H3>To safely allow restricted HTML input </H3><OL><LI>Disable ASP.NET request validation by the adding the <B>ValidateRequest="false"</B> attribute to the <B>&#64; Page</B> directive. <LI>Encode the string input with the <B>HtmlEncode</B> method. <LI>Use a <B>StringBuilder</B> and call its <B>Replace</B> method to selectively remove the encoding on the HTML elements that you want to permit. </LI></OL><P>The following .aspx page code shows this approach. The page disables ASP.NET request validation by setting <B>ValidateRequest="false"</B>. It HTML-encodes the input and then selectively allows the &lt;<B>b</B>&gt; and &lt;<B>i</B>&gt; HTML elements to support simple text formatting. </P><DIV><PRE>&lt;&#37;&#64; Page Language="C#" ValidateRequest="false"&#37;&gt;</PRE><PRE>&lt;script runat="server"&gt;</PRE><PRE>&nbsp; void submitBtn_Click(object sender, EventArgs e)<BR>&nbsp; &#123;<BR>&nbsp;&nbsp;&nbsp; // Encode the string input<BR>&nbsp;&nbsp;&nbsp; StringBuilder sb = new StringBuilder(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AntiXSSLibrary.HtmlEncode(htmlInputTxt.Text));<BR>&nbsp;&nbsp;&nbsp; // Selectively allow&nbsp; &lt;b&gt; and &lt;i&gt;<BR>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;b&amp;gt;", "&lt;b&gt;");<BR>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;/b&amp;gt;", "");<BR>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;i&amp;gt;", "&lt;i&gt;");<BR>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;/i&amp;gt;", "");<BR>&nbsp;&nbsp;&nbsp; Response.Write(sb.ToString());<BR>&nbsp; &#125;<BR>&lt;/script&gt;</PRE></DIV><PRE>&lt;html&gt;<BR>&nbsp; &lt;body&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;form id="form1" runat="server"&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;div&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:TextBox ID="htmlInputTxt" Runat="server" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextMode="MultiLine" Width="318px"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Height="168px"&gt;&lt;/asp:TextBox&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Button ID="submitBtn" Runat="server" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text="Submit" OnClick="submitBtn_Click" /&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/div&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;/form&gt;<BR>&nbsp; &lt;/body&gt;<BR>&lt;/html&gt;</PRE><H1>Additional Considerations</H1><P>In addition to the techniques discussed previously in this How to, use the following countermeasures as further safe guards to prevent cross-site scripting: </P><UL><LI>Set the correct character encoding. <LI>Do not rely on input sanitization. <LI>Use the HttpOnly cookie option. <LI>Use the &lt;frame&gt; security attribute. <LI>Use the innerText property instead of innerHTML. </LI></UL><H2>Set the Correct Character Encoding</H2><P>To successfully restrict valid data for your Web pages, you should limit the ways in which the input data can be represented. This prevents malicious users from using canonicalization and multi-byte escape sequences to trick your input validation routines. A multi-byte escape sequence attack is a subtle manipulation that uses the fact that character encodings, such as uniform translation format-8 (UTF-8), use multi-byte sequences to represent non-ASCII characters. Some byte sequences are not legitimate UTF-8, but they may be accepted by some UTF-8 decoders, thus providing an exploitable security hole.</P><P>ASP.NET allows you to specify the character set at the page level or at the application level by using the &lt;<B>globalization</B>&gt; element in the Web.config file. The following code examples show both approaches and use the ISO-8859-1 character encoding, which is the default in early versions of HTML and HTTP.</P><P>To set the character encoding at the page level, use the &lt;<B>meta</B>&gt; element or the <B>ResponseEncoding</B> page-level attribute as follows: </P><DIV><PRE>&lt;meta http-equiv="Content Type" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; content="text/html; charset=ISO-8859-1" /&gt;</PRE><PRE>OR<BR>&lt;&#37; &#64; Page ResponseEncoding="iso-8859-1" &#37;&gt;  </PRE></DIV><P>To set the character encoding in the Web.config file, use the following configuration.</P><DIV><PRE>&lt;configuration&gt;<BR>&nbsp;&nbsp; &lt;system.web&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;globalization <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requestEncoding="iso-8859-1"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; responseEncoding="iso-8859-1"/&gt;<BR>&nbsp;&nbsp; &lt;/system.web&gt;<BR>&lt;/configuration&gt;  </PRE></DIV><H2>Validating Unicode Characters</H2><P>Use the following code to validate Unicode characters in a page.</P><DIV><PRE>using System.Text.RegularExpressions;<BR>. . .</PRE><PRE>public class WebForm1 : System.Web.UI.Page<BR>&#123;<BR>&nbsp; private void Page_Load(object sender, System.EventArgs e)<BR>&nbsp; &#123;<BR>&nbsp;&nbsp;&nbsp; // Name must contain between 1 and 40 alphanumeric characters<BR>&nbsp;&nbsp;&nbsp; // and (optionally) special characters such as apostrophes&nbsp; <BR>&nbsp;&nbsp;&nbsp; // for names such as O'Dell</PRE><PRE>&nbsp;&nbsp;&nbsp; if (&#33;Regex.IsMatch(Request.Form&#91;"name"&#93;,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#64;"&#94;&#91;\p&#123;L&#125;\p&#123;Zs&#125;\p&#123;Lu&#125;\p&#123;Ll&#125;\'&#93;&#123;1,40&#125;&#36;"))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ArgumentException("Invalid name parameter");</PRE><PRE>&nbsp;&nbsp;&nbsp; // Use individual regular expressions to validate other parameters<BR>&nbsp;&nbsp;&nbsp; . . .<BR>&nbsp; &#125;<BR>&#125;  </PRE></DIV><P>The following explains the regular expression shown in the preceding code: </P><UL><LI><B>&#94;</B> means start looking at this position. <LI><B>\p&#123; ..&#125;</B> matches any character in the named character class specified by <B>&#123;..&#125;</B>. <LI><B>&#123;L&#125;</B> performs a left-to-right match. <LI><B>&#123;Lu&#125;</B> performs a match of uppercase. <LI><B>&#123;Ll&#125;</B> performs a match of lowercase. <LI><B>&#123;Zs&#125;</B> matches separator and space. <LI><B>'</B>matches apostrophe. <LI><B>&#123;1,40&#125;</B> specifies the number of characters: no less than 1 and no more than 40. <LI>&#36; means stop looking at this position. </LI></UL><H2>Do Not Rely on Input Sanitization</H2><P>A common practice is for code to attempt to sanitize input by filtering out known unsafe characters. Do not rely on this approach because malicious users can usually find an alternative means of bypassing your validation. Instead, your code should check for known secure, safe input. Table 1 shows various safe ways to represent some common characters.</P><P><B>Table 1: Character Representation</B></P><DIV><TABLE><TBODY><TR><TH>Characters</TH><TH>Decimal</TH><TH>Hexadecimal</TH><TH>HTML Character Set</TH><TH>Unicode</TH></TR><TR><TD><B>" </B>(double quotation marks)</TD><TD>&amp;#34</TD><TD>&amp;#x22</TD><TD>&amp;quot;</TD><TD>\u0022</TD></TR><TR><TD><B>' </B>(single quotation mark)</TD><TD>&amp;#39</TD><TD>&amp;#x27</TD><TD>&amp;apos;</TD><TD>\u0027</TD></TR><TR><TD><B>&amp;</B> (ampersand)</TD><TD>&amp;#38</TD><TD>&amp;#x26</TD><TD>&amp;amp;</TD><TD>\u0026</TD></TR><TR><TD>&lt; (less than)</TD><TD>&amp;#60</TD><TD>&amp;#x3C</TD><TD>&amp;lt;</TD><TD>\u003c</TD></TR><TR><TD>&gt; (greater than)</TD><TD>&amp;#62</TD><TD>&amp;#x3E</TD><TD>&amp;gt;</TD><TD>\u003e</TD></TR></TBODY></TABLE></DIV><P><H2>Use the HttpOnly Cookie Option</H2><P>Internet Explorer 6 Service Pack 1 and later supports an <B>HttpOnly</B> cookie attribute, which prevents client-side scripts from accessing a cookie from the <B>document.cookie</B> property. Instead, the script returns an empty string. The cookie is still sent to the server whenever the user browses to a Web site in the current domain.</P><BLOCKQUOTE><B>Note</B>&nbsp;&nbsp;&nbsp;Web browsers that do not support the <B>HttpOnly</B> cookie attribute either ignore the cookie or ignore the attribute, which means that it is still subject to cross-site scripting attacks.<B> </B></BLOCKQUOTE><P>The <B>System.Net.Cookie</B> class in Microsoft .NET Framework version 2.0 supports an <B>HttpOnly</B> property. The <B>HttpOnly</B> property is always set to true by Forms authentication. </P><P>Earlier versions of the .NET Framework (versions 1.0 and 1.1) require that you add code similar to the following to the <B>Application</B>_<B>EndRequest</B> event handler in your application Global.asax file to explicitly set the <B>HttpOnly</B> attribute.</P><DIV><PRE>protected void Application_EndRequest(Object sender, EventArgs e) <BR>&#123;<BR>&nbsp; string authCookie = FormsAuthentication.FormsCookieName;<BR>&nbsp; foreach (string sCookie in Response.Cookies) <BR>&nbsp; &#123;<BR>&nbsp;&nbsp;&nbsp; // Just set the HttpOnly attribute on the Forms <BR>&nbsp;&nbsp;&nbsp; // authentication cookie. Skip this check to set the attribute <BR>&nbsp;&nbsp;&nbsp; // on all cookies in the collection</PRE></DIV><PRE>&nbsp;&nbsp;&nbsp; if (sCookie.Equals(authCookie))<BR>&nbsp;&nbsp;&nbsp; &#123; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Force HttpOnly to be added to the cookie header<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Cookies&#91;sCookie&#93;.Path &#43;= ";HttpOnly";<BR>&nbsp;&nbsp;&nbsp; &#125;<BR>&nbsp; &#125;<BR>&#125;</PRE><H2>Use the &lt;frame&gt; Security Attribute</H2><P>Internet Explorer 6 and later support a new <B>security</B> attribute for the &lt;<B>frame</B>&gt; and &lt;<B>iframe</B>&gt; elements. You can use the <B>security</B> attribute to apply the user's Restricted Sites Internet Explorer security zone settings to an individual frame or iframe. By default, the Restricted Sites zone does not support script execution. </P><P>If you use the <B>security</B> attribute, it must be set to <B>"restricted"</B> as shown in the following.</P><DIV><DIV><DIV></DIV><DIV>&nbsp;</DIV></DIV><PRE>&lt;frame security="restricted" src="http://www.somesite.com/somepage.htm"&gt;&lt;/frame&gt;  </PRE></DIV><H2>Use the innerText Property Instead of innerHTML</H2><P>If you use the <B>innerHTML</B> property to build a page and the HTML is based on potentially untrusted input, you must use <B>HtmlEncode</B> to make it safe. To avoid having to remember to do this, use <B>innerText</B> instead. The <B>innerText</B> property renders content safe and ensures that scripts are not executed.</P><P>The following example shows this approach for two HTML &lt;<B>span</B>&gt; controls. The code in the <B>Page_Load</B> method sets the text displayed in the <B>Welcome1</B> &lt;<B>span</B>&gt; element using the <B>innerText</B> property, so HTML-encoding is unnecessary. The code sets the text in the <B>Welcome2</B> &lt;<B>span</B>&gt; element by using the <B>innerHtml</B> property; therefore, you must <B>HtmlEncode</B> it first to make it safe.</P><DIV><PRE>&lt;&#37;&#64; Page Language="C#" AutoEventWireup="true"&#37;&gt;</PRE><PRE>&lt;html&gt;<BR>&nbsp; &lt;body&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;span id="Welcome1" runat="server"&gt; &lt;/span&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;span id="Welcome2" runat="server"&gt; &lt;/span&gt;<BR>&nbsp; &lt;/body&gt;<BR>&lt;/html&gt;</PRE></DIV><PRE>&lt;script runat="server"&gt;<BR>&nbsp; private void Page_Load(Object Src, EventArgs e)<BR>&nbsp; &#123;<BR>&nbsp;&nbsp;&nbsp; // Using InnerText renders the content safe-no need to HtmlEncode<BR>&nbsp;&nbsp;&nbsp; Welcome1.InnerText = "Hello, " &#43; User.Identity.Name;</PRE><PRE>&nbsp;&nbsp;&nbsp; // Using InnerHtml requires the use of HtmlEncode to make it safe<BR>&nbsp;&nbsp;&nbsp; Welcome2.InnerHtml = "Hello, " &#43; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Server.HtmlEncode(User.Identity.Name);<BR>&nbsp; &#125;<BR>&lt;/Script&gt;</PRE><HR><P>Adapted from Microsoft patterns &amp; practices guidance.</P>
]]></content></guidanceItem>