<?xml version="1.0" encoding="utf-8"?><guidanceItem id="73fc5ea6-1115-4210-92bd-1941e4f46e25" type="howto" title="How to Test For SQL Injection Bugs" cssFile="guidance.css" Date="2011-01-20T03:18:06.671875Z" Author="" Category="Input and Data Validation" filePath="..\Libraries\OWASP\How To\73fc5ea6-1115-4210-92bd-1941e4f46e25.xml" Priority="J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan" Rule_Type="Test" Source="OWASP" Status="" Technology=" Any" Topic="Security" Type="How To" xmlns="urn:microsoft:guidanceexplorer:guidanceItem"><content><![CDATA[<BR><BR><H1>Applies to</H1><P>All applications that interact with a database such as: </P><UL><LI>Web applications written ASP, ASP .NET, PHP, Visual Basic, C#, Java, or Perl using a database <LI>Non web-applications that interact with database back-end</LI></UL><P></P><H1>Summary</H1><P>SQL Injection is a common type of web database related vulnerability.&nbsp;&nbsp; SQL injection is common to web site applications that interact with a database backend.&nbsp; These sites construct SQL commands or queries based on user input.&nbsp; For example they might search a product database based on a description a user typed in a web form.&nbsp; An application is vulnerable to SQL injection when it builds SQL queries without filtering the user's input, without using store procedure, or without binding parameters variables.&nbsp; This can lead to an attacker adding additional clauses, conditions, or even commands that execute along the original query.&nbsp;&nbsp;&nbsp; Attackers can use SQL Injection bugs to execute different types of attacks such as data theft and tampering, authentication bypass, information disclosure, and elevation of privileges.</P><P>Below is a summary of steps needed for testing for SQL injection bugs</P><UL><LI><B>Step 1</B>:&nbsp; Understand SQL injection attack scenarios <LI><B>Step 2</B>:&nbsp; List high risk components and entry points <LI><B>Step 3</B>:&nbsp; Start testing and exploring <LI><B>Step 4</B>:&nbsp; Tune of test data</LI></UL><P></P><P><B>Step 1:&nbsp; Understand Attack Scenarios</B></P><P>It is important to understand attack scenarios so that you know what to look for when testing for SQL injection.&nbsp; Here are two common attack scenarios:</P><UL><LI>Search Engine scenario <LI>Form Authentication scenario</LI></UL><P><B><I>Search engine scenario</I></B></P><P>Most web sites have search pages that take a search query from the user, create a SQL query with it, execute the query at a SQL backend database, and return the results to the user.&nbsp; These components will end up creating a SQL similar to this:</P><PRE>SELECT &#42; item, description FROM products WHERE description LIKE usersearch (from input)</PRE><P>For instance, a web server takes search data from the user either from a form or from a URL that looks like this:</P><PRE>http://www.teammentorexample.com/products/search.php?prod=bike (PHP)</PRE><PRE>http://www.teammentorexample.com/products/search.asp?prod=bike (ASP)</PRE><P>The server might use code like this in the search component: </P><PRE>&#36;query = "select item, description from productTable where description LIKE '&#37;" . &#36;_GET&#91;"prod"&#93; . "&#37;'"&nbsp;&nbsp; (PHP)</PRE><PRE>var query = "select item, description from productTable where description LIKE '&#37;" &#43; Request.QueryString("prod") &#43; "&#37;'"&nbsp; (ASP)</PRE><P>In both of the cases above the attacker can modify the URL and inject SQL statements that will be concatenated to the query and executed as part of the SQL query.&nbsp; If the attacker changes the value passed in prod by:</P><PRE>any OR 1=1</PRE><P>Then the query will return all of the rows in the table since the second condition 1=1 will be always true:&nbsp; </P><P>SELECT &#42; item, description FROM products WHERE description LIKE 'any' OR 1=1</P><P><B><I>Forms authentication scenario</I></B></P><P>Another example of a high risk component is the code used in forms authentication. For example, the code below, accepts credentials to build a SELECT query to validate the user.&nbsp; The data is passed to the login.php page through a web form's POST using username and password variables.&nbsp; </P><P>A SQL injection bug is present in this code:</P><PRE>&#36;query = "SELECT &#42; FROM Accounts WHERE UserName = '" . &#36;_POST&#91;'name'&#93; . "'" . " AND password = '" . &#36;_POST&#91;'pass'&#93; . "'"; </PRE><PRE>&#36;result = odbc_exec(&#36;connection, &#36;query);</PRE><PRE>if (&#36;result_count == 0) &#123;</PRE><PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print('unable to login');</PRE><PRE>&#125;</PRE><PRE>else &#123;</PRE><PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print('user logged in');</PRE><PRE>&#125;</PRE><P>An attacker can submit the same string as in the first scenario:</P><PRE>any OR 1=1</PRE><P>This will result in the following statement constructed:</P><PRE>SELECT &#42; FROM Accounts WHERE UserName = any or 1=1</PRE><P>The statement returns all rows from the Accounts table.&nbsp; The if condition in the code will be false and the attacker will be able to log in without a valid password.</P><P><B><I>Stored procedure scenario</I></B></P><P>SQL injection bugs aren';t necessarily restricted to the application layer.&nbsp; For instance, a stored procedure used at the database layer may also suffer from SQL injection.&nbsp; Consider the following procedure that takes a parameter for a product name and searches a database by building a dynamic SELECT statement inside:</P><P>&nbsp;</P><PRE>CREATE PROCEDURE sp_SearchProducts &#64;prodname varchar(400) = NULL AS</PRE><PRE>DECLARE &#64;sql nvarchar(4000)</PRE><PRE>SELECT &#64;sql = ' SELECT ProductID, ProductName, Category, Price ' &#43;</PRE><PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' FROM Product Where ProductName LIKE ''' &#43; &#64;prodname &#43; ''''</PRE><PRE>EXEC (&#64;sql)</PRE><P>&nbsp;</P><P>The can invoke the procedure at the application layer like this:</P><PRE>exec sp_SearchProducts('any'' OR 1=1--')</PRE><P>The final statement will look like this:</P><PRE>SELECT ProductID, ProductName, Category, Price FROM Product Where ProductName LIKE 'any' OR 1=1&#8212;'</PRE><P>&nbsp;</P><P>This will return all rows of the product table.&nbsp; </P><P>Be careful with this type of scenario since it is a common misbelieve that using stored procedures and bound parameters solve SQL injection automatically.</P><P>&nbsp;</P><P><B>Step 2: List High Risk Components and Entry Points</B></P><P>The next step for SQL Injection testing is to list all the places where code builds SQL statements from user supplied input; to understand how and where our application manipulates statement and talks to a database.&nbsp; The most common are:</P><UL><LI>Search web pages <LI>Profile-related web pages <LI>Authentication forms <LI>E-Commerce or financial account-related pages <LI>Database interaction public API's and DCOM methods <LI>Database system-level clients</LI></UL><P><B><I>Identify all high risk components </I></B></P><P>After understanding the details of SQL Injection, list their high risk components in a table that includes the method that hosts the code, the name of the query string if available, and the variable names that influence the construction of the query&nbsp;</P><P>Look at code like the one shown in the scenarios above; code where SQL statements are built using web input.&nbsp; Then list all of these web pages as high risk components.</P><P><B><I>Match High Risk Components with Entry Points</I></B></P><P>After listing all areas in the application where SQL statements are built at run-time, you&nbsp; must identify the ways in which data gets to these places.&nbsp; For example, you listed a web page named "search.asp" above that constructs SQL statements dangerously.&nbsp; Here you list how this page gets its input; what are its entry points.&nbsp; Keep in mind that entry points can be both intended (expected by the program or application) and unintended (unexpected by program or application).&nbsp; A common list of entry points for SQL injection high risk components include:</P><UL><LI>URL bar contents <LI>Web form input values <LI>Web service methods <LI>Network packets <LI>Public API's <LI>DCOM methods <LI>Application UI text fields <LI>Inter Process Communication pipe</LI></UL><P>The first three are the most common entry points for web services and application.&nbsp; Nonetheless, always look for new entry points additional entry points not listed here.&nbsp; Make sure that the data manipulated by the component at risk is not passed by any other means.</P><P>Ideally by the end of step 2 you will have a table like the one shown above to systematically guide test execution.</P><P><B>Step 3: Start Testing and Exploring </B></P><P>The following step is to start supplying input to the application that gives hints of possible SQL injection bugs.&nbsp; With the list made during step 2, you can systematically walk through all variables and start exploring how the test input is handled.&nbsp; In this step, we recommend to execute a first pass using fuzz strings and basic conditions.</P><P><B><I>Start with a simple fuzz string</I></B></P><P>The first recommended test is to add some string and a single quote or parenthesis at the end of it.&nbsp; In most SQL Injection cases this kind of string will generate a server side error that will be displayed back in the client's browser:</P><PRE>xyz') "&#93;</PRE><P>Then see how the server reacts to it.&nbsp; In some cases it will strip out the special characters: this is a sign that it protects against injection.&nbsp; However, in other cases the application may return a SQL related error messages because a special character such as the single quote unexpectedly closed a statement.&nbsp; It then can be deduced that the statement was being built dynamically.&nbsp; This is a clear indication that you need to keep looking to see whether a SQL injection bug actually exists.</P><P><B><I>Continue with simple true and false conditions</I></B></P><P>The next step is to try to add a simple SQL statement.&nbsp; The simplest you can try is an integer comparison such as 1=1 or 2&gt;1 or a character comparison such as 'a'='a' proceeded by an OR.&nbsp; For instance:</P><PRE>xyz' OR 1=1 --</PRE><P>&nbsp;Then observe the results.&nbsp; Look for any indication that the o injected true statement returned all rows of a table.&nbsp; Then try a false statement and look at the difference.</P><PRE>xyz' OR 1&gt;2 --</PRE><P>If the results are visibly different in quantity or in server behavior, then the possibility for a SQL injection bugs is high.&nbsp; Even if no information about the database structure or no other serious attack is possible, you can determine SQL injection by observing basic server and error messages.&nbsp; </P><P>Consider the following scenario.&nbsp; The string "xyz' OR 1=1" -is submitted and the server returns a 500 error that says:</P><PRE>&nbsp;"Results Buffer too Large" and when "xyz' OR 1&gt;2 -" </PRE><P>is submitted the server returns a valid page saying that there were no matches.&nbsp; So when the condition is true the server chokes with results.&nbsp; When it's false it returns no results.&nbsp; In this case, the processing of the injected condition is evident and means that there is a SQL injection bug.&nbsp; It might not be exploitable but it exists and this simple difference in server behavior is enough to prove that it does.</P><P><B><I>NOTE: Be careful with valid numerical results</I></B></P><P>Make sure that when using numerical comparisons the results are different because of the comparison and not because of the content.&nbsp; For example, if when using 1=1 the server returns phone numbers with "11" and when 1&gt;2 returns "21" numbers or matches then it means that is not processing the actual comparison.&nbsp; The results are different because the application is querying over the numbers 1 and 2.&nbsp; The server is not executing the extra conditions as separate statements; it is correctly including them as part of the data to search, and there is no evidence of a SQL injection vulnerability.&nbsp; You need to be careful about this scenario and realize when the extra condition is actually being executed separately or not.</P><P><B>Step 4: Tune test cases data </B></P><P>At this point you have started executing an exploratory pass through the input variables.&nbsp; During step 4 you need to concentrate on covering all entry points of each variable in your variable table.</P><P><B><I>Learn type database version </I></B></P><P>Different database applications and versions process queries differently.&nbsp; For example SQL Server uses &#43; to concatenate strings in a statement while Oracle uses &#124;&#124;.&nbsp;&nbsp; SQL Server allows execution of batched or multiple SQL commands within a statement as long as they are separated with a semicolon (;) while Oracle and MySQL forbids this.&nbsp; You can gather database brand and versions by scanning network ports at the server, sniffing network traffic, or looking at SQL related error messages.</P><P><B><I>Consider string format and encoding according to entry point</I></B></P><P>As you walk through the risky variables and entry points take into account the different formats that apply to each entry point.&nbsp; For example, this article described passing the following string to a web form:</P><PRE>xyz' OR 1=1 --</PRE><P>However, you can't pass a string like the one above in a URL since the URL doesn't allow blank spaces.&nbsp; Server applications use different encoding functions to transmit URL contents.&nbsp; They encode data and then decode it at the server end.&nbsp; The encoding and decoding depends on the server's programming language.&nbsp; For example, sometimes the encoding function replaces the blank spaces with a plus (&#43;) sign so the string above looks like this:</P><PRE>xyz'&#43;OR&#43;1=1&#43;--</PRE><P>In other encoding case, the server might replace the blank space with a &#37;20.&nbsp; In that case, the test string will need to look like this:</P><PRE>xyz'&#37;20OR&#37;201=1&#37;20--</PRE><P>This common encoding scheme consists of replacing spaces with their hexadecimal values &#37;HH.&nbsp; In addition, it is recommended to also encode reserved characters such as the single quote.&nbsp; The encoded string will then look like this:</P><PRE>xyz&#37;27&#43;OR&#43;1&#37;3D1&#43;--</PRE><P>The Java URL encode function translates special characters using a string like this one &#37;uXXXX where XXXX is the character&#180;s Unicode value represented as four digits.&nbsp; The above string will look like this one:</P><PRE>xyz&#37;u2019&#43;OR&#43;1&#37;3D1&#43;--</PRE><P>There are different types of encoding mechanisms.&nbsp; It is important that you do a quick source review to see what encoding functions are used and then at the documentation available for the specific functions. To learn more, see "Percent Encoding" at <A href="http://en.wikipedia.org/wiki/Percent-encoding">http://en.wikipedia.org/wiki/Percent-encoding</A>.</P><P><B><I>Note:&nbsp; Try to use double encoding</I></B></P><P>It is important to attempt to execute double encoding cases.&nbsp;&nbsp; Double encoding is a specific encoding aimed at bypassing security controls.&nbsp; It consists of replacing the percent character by its hexadecimal value (25).&nbsp; If you are testing using single encoding like this:</P><PRE>xyz&#37;27&#43;OR&#43;1&#37;3D1&#43;--</PRE><P>Then try the following string for double encoding:</P><PRE>xyz&#37;2527&#43;OR&#43;1&#37;253D1&#43;--</PRE><P><B><I>Try different syntax</I></B></P><P>SQL injection testing aims at changing the logic of the original SQL statement by adding additional ones.&nbsp; But for the additional statements to execute, the attacked query has to remain syntactically correct or else it will fail to execute.&nbsp; Consider different variants of test input to deal with the closing of quotes and parenthesis.&nbsp; Here are a few variations to try:</P><UL><LI>x' or 1=1 -- <LI>x' or 'a'='a <LI>x" or 1=1 # <LI>x&#37;' or 1=1 --&nbsp;&nbsp;&nbsp;&nbsp; <LI>x&#37;" or 1=1 # <LI>x') or 1=1 # &nbsp;&nbsp;&nbsp;&nbsp; <LI>x') or 'a'='a' -- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <LI>x') or ('a'='a</LI></UL><P><B><I>Consider the different ways of getting test results</I></B></P><P>There are different channels to retrieve SQL injection data:</P><UL><LI><B>In band</B> - When the attacked server returns the data to the attacker using an existing channel such as a rendered table in a web page, or by logging on the user to a restricted page <LI><B>Out of band</B> - When the attacker opens a new connection to get data from the server such as when installing a Trojan in the server, using an extended stored procedure such as xp_cmdshell to open a remote connection, or using MS SQL's OPENROWSET() to connect directly to the database. <LI><B>Inferred</B> - When the attacked server doesn't send any data to the attacker and the attacker needs to execute his attack using alternate queries and observing error codes.</LI></UL><P>Cover the different methods of retrieving data from the server during this step.&nbsp;&nbsp;<B><I>&nbsp;</I></B></P><P><B><I>Execute different payloads</I></B></P><P>Sometimes executing a simple true or false condition will not generate visible results.&nbsp; This is the main reasons why you need to try different payloads.&nbsp; There are hundreds of possible payloads to execute in a SQL injection attack.&nbsp; Most of these payloads vary between SQL server applications and can be found in the web.&nbsp; Just to get an idea of how different payloads can be, let's picture the case of trying to steal information from a database. &nbsp;The payload can vary between:</P><UL><LI>An OR with simple condition that returns all rows (like OR 1=1) <LI>An UNION SELECT statement that executes and additional SELECT query and appends the results to the original result set. To learn more, see&nbsp;<A href="http://www.securitydocs.com/pdf/2656.PDF">SQL Injection:&nbsp; Are your Web Applications Vulnerable?</A> <LI>An OPENROWSET command that opens a connection to a hacker database and sends the data to the remote attacker. To learn more, see <A href="http://www.appsecinc.com/presentations/Manipulating_SQL_Server_Using_SQL_Injection.pdf">Manipulating Microsoft SQL Server Using SQL Injection</A> <LI>A call to a stored procedure such as xp_cmdshell to open a backdoor or install a Trojan that will send the information back to the attacker <LI>An inference attack that uses CASE statements to get data byte by byte. To learn more, see <A href="http://www.ngssoftware.com/papers/sqlinference.pdf">Data-mining with SQL Injection and Inference</A></LI></UL><P>Tampering also has different scenarios:</P><UL><LI>An additional DROP statement to drop a table from a database <LI>An additional INSERT statement to add a record to a table <LI>An additional UPDATE statement to replace existing data in a table</LI></UL><P>You need to try different payloads.&nbsp;&nbsp; We recommend listing all the payloads that can be executed against the database under test.&nbsp;&nbsp; Then to execute each payload with the syntactic variations previously mentioned.&nbsp; By doing this, you will expand their SQL injection test cases to get maximum testing coverage. </P><P>Nevertheless, keep in mind that it is also important not to overdo payload testing.&nbsp; If you realize that a specific variable-entry point is not susceptible to SQL injection (it might be parameterized or escaped of its command characters) then move on to the next variable and not spend unnecessary time testing numerous payloads.&nbsp; </P><P><B><I>NOTE:&nbsp; Use proper test monitors or indicators</I></B></P><P>When testing injection, especially out of bands that opens a separate channel to send data back, make sure to have in indicator that waits for the test to pass or fail.&nbsp; If the payload opens a backdoor then connect to the backdoor.&nbsp;&nbsp; If the payload copies a database to a remote database then have that server set up and ready to receive the stolen data.&nbsp;&nbsp; Having proper indicators and monitors in place is the only way to find out the results of all test cases.</P><P><B><I>Learn database structure and use to tune test cases</I></B></P><P>In almost all information disclosure and tampering scenarios, the attacker will need to know table and column names.&nbsp;&nbsp; One way to successfully discover database details is to use error messages smartly.&nbsp;&nbsp; Another way to discover database structure such as table names and columns is to brute force table names or column names and look for valid ones.&nbsp; Finally, you can discover details about the database using inference techniques.</P><P></P><H1>Conclusions</H1><P>Good SQL Injection testing relies on proper coverage of all SQL related input variables through their different entry points.&nbsp; Start by understanding attack scenarios and doing a comprehensive analysis of the application's SQL related input variables, query construction, and entry points.&nbsp; Then try basic tests, tune the test data based on different entry points, and look carefully how the application reacts.&nbsp;&nbsp; Finally, tune your data using the appropriate payloads and keep tuning test case data with learned or inferred database structure.</P><H1>Additional Resources&nbsp;</H1><DIV><BR></DIV><UL><LI>Percent Encoding.&nbsp; Wikipedia. <A href="http://en.wikipedia.org/wiki/Percent-encoding">http://en.wikipedia.org/wiki/Percent-encoding</A> <LI><A href="http://www.securitydocs.com/pdf/2656.PDF">SQL Injection:&nbsp; Are your Web Applications Vulnerable? Kevin Spett.&nbsp; Spi Dynamics.</A> <LI><A href="http://www.appsecinc.com/presentations/Manipulating_SQL_Server_Using_SQL_Injection.pdf">Manipulating Microsoft SQL Server Using SQL&nbsp; Injection. Cesar Cerrudo. Application Security, Inc.</A> <LI><A href="http://www.ngssoftware.com/papers/sqlinference.pdf">Data-mining with SQL Injection and Inference. &nbsp;David Litchfield.&nbsp; NGS Software.</A></LI></UL><H1>Related Items</H1><UL><LI><A href="ruledisplay:1D4FA7AF-33F0-40D9-9665-A31DBF3D7764">Attack: SQL Injection Attack</A></LI></UL>]]></content></guidanceItem>