<?xml version="1.0" encoding="utf-8"?><guidanceItem id="6bfe7761-6f2a-43c2-a104-7ad3063affb3" type="howto" title="How to Protect From Injection Attacks in ASP.NET" cssFile="guidance.css" Date="2010-06-24T20:02:01.7393945Z" Author="" Category="Input and Data Validation" filePath="..\Libraries\OWASP\How To\6bfe7761-6f2a-43c2-a104-7ad3063affb3.xml" Priority="" Rule_Type="Implementation" Source="ASP.NET 3.5" Status="" Technology="ASP.NET 3.5" Topic="Security" Type="How To" xmlns="urn:microsoft:guidanceexplorer:guidanceItem"><content><![CDATA[<H1>Summary</H1><P>This How to shows how you can validate input to protect your application from injection attacks. Performing input validation is essential because almost all application-level attacks contain malicious input. </P><P>You should validate all input, including form fields, query string parameters, and cookies to protect your application against malicious command injection. Assume all input to your Web application is malicious, and make sure that you use server validation for all sources of input. Use client-side validation to reduce round trips to the server and to improve the user experience, but do not rely on it because it is easily bypassed. </P><P>To validate input, define acceptable input for each application input field. A proven practice is to constrain input for length, range, format, and type. Use the list of acceptable characters to define valid input, instead of the list of unacceptable characters. Using the list of unacceptable characters is impractical because it is very difficult to anticipate all possible variations of bad input.</P><P>When you need to accept a range of HTML characters, make sure that you HTML-encode the data to make it safe prior to displaying it as output.</P><H1>Contents</H1><UL><LI><DIV>Objectives</DIV><LI><DIV>Overview</DIV><LI><DIV>Summary of Steps</DIV><LI><DIV>Step 1. Use ASP.NET Request Validation</DIV><LI><DIV>Step 2. Constrain Input</DIV><LI><DIV>Step 3. Encode Unsafe Output</DIV><LI><DIV>Step 4. Use Command Parameters for SQL Queries</DIV><LI><DIV>Step 5. Verify that ASP.NET Errors Are Not Returned to the Client</DIV><LI><DIV>Additional Resources</DIV></LI></UL><H1>Objectives</H1><UL><LI>Constrain input for length, range, format, and type. <LI>Apply ASP.NET request validation during development to identify injection attacks. <LI>Constrain input by using ASP.NET validator controls. <LI>Encode unsafe output. <LI>Help prevent SQL injection by using command parameters. <LI>Prevent detailed error information from returning to the client. </LI></UL><H1>Overview</H1><P>You need to validate all untrusted input to your application. You should assume that any input from users is malicious. User input to your Web application includes form fields, query strings, client-side cookies, and browser environment values such as user agent strings and IP addresses. </P><P>Weak input validation is a common vulnerability that could allow your application to be exploited by a number of injection attacks. The following are common types of attacks that exploit weak or missing input validation: </P><UL><LI><B>SQL injection. </B>If you generate dynamic SQL queries based on user input, an attacker could inject malicious SQL commands that can be executed by the database. <LI><B>Cross-site scripting.</B> Cross-site scripting (XSS) attacks exploit vulnerabilities in Web page validation by injecting client-side script code. This code is subsequently sent to an unsuspecting user's computer and executed on the browser. Because the browser downloads the script code from a trusted site, the browser has no way of determining whether the code is legitimate. <LI><B>Unauthorized file access.</B> If your code accepts input from a caller, a malicious user could potentially manipulate your code's file operations, such as accessing a file they should not access or exploiting your code by injecting bad data. </LI></UL><BLOCKQUOTE><B>Note</B>&nbsp;&nbsp;&nbsp;Injection attacks work over HTTP and HTTPS Secure Socket Layer (SSL) connections. Encryption provides no defense.</BLOCKQUOTE><P>The general approach for input validation is summarized here. You should apply this approach to any input that comes from the network, such as text boxes and other forms field input, query string parameters, cookies, server variables, and Web method parameters. Note that the strategy is to first allow only good input and then deny bad input. This is because you can easily define good input for your application, but you cannot realistically anticipate the format for all malicious input. </P><P>Check for valid input as follows: </P><UL><LI><B>Constrain: </B>Check for known good data by validating the type, length, format, and range. To constrain input from server controls, use the ASP.NET validator controls. To constrain input from other sources, use regular expressions and custom validation. <LI><B>Reject:</B> Check for any known bad data and reject bad input. <LI><B>Sanitize:</B> Sometimes you also need to sanitize input and make potentially malicious input safe. For example, if your application supports free-format input fields, such as comment fields, you might want to permit certain safe HTML elements, such as &lt;<B>b</B>&gt; and &lt;<B>i</B>&gt;, and eliminate any other HTML elements. </LI></UL><H1>Summary of Steps</H1><P>To protect your ASP.NET application from injection attacks, perform the following steps: </P><UL><LI>Step 1. Use ASP.NET request validation. <LI>Step 2. Constrain input. <LI>Step 3. Encode unsafe output. <LI>Step 4. Use command parameters for SQL queries. <LI>Step 5. Verify that ASP.NET errors are not returned to the client. </LI></UL><P>The next sections describe each of these.</P><H1>Step 1. Use ASP.NET Request Validation</H1><P>By default, ASP.NET request validation detects any HTML elements and reserved characters in data posted to the server. This helps prevent users from inserting script into your application. Request validation checks all input data against a hard-coded list of potentially dangerous values. If a match occurs, it throws an exception of type <B>HttpRequestValidationException</B>.</P><P>You can disable request validation in your Web.config application configuration file by adding a &lt;<B>pages</B>&gt; element with <B>validateRequest="false"</B> or on an individual page by setting <B>ValidateRequest="false"</B> on the <B>&#64; Pages</B> element. </P><P>If you need to disable request validation, you should disable it only on the affected page. An example of this is when you have a page with a free-format text field that accepts HTML-formatted input.</P><H2>Confirm that ASP.NET Request Validation Is Enabled in Machine.config</H2><P>Request validation is enabled by ASP.NET by default. You can see the following default setting in the Machine.config.comments file.</P><DIV><PRE>&lt;pages validateRequest="true" ... /&gt;  </PRE></DIV><P>Confirm that you have not disabled request validation by overriding the default settings in your server's Machine.config file or your application's Web.config file. </P><H2>Test ASP.NET Request Validation</H2><P>You can test the effects of request validation. To do this, create an ASP.NET page that disables request validation by setting <B>ValidateRequest="false"</B>, as follows.</P><DIV><PRE>&lt;&#37;&#64; Language="C#" ValidateRequest="false" &#37;&gt;<BR>&lt;html&gt;<BR>&nbsp;&lt;script runat="server"&gt;<BR>&nbsp; void btnSubmit_Click(Object sender, EventArgs e)<BR>&nbsp; &#123;<BR>&nbsp;&nbsp;&nbsp; // If ValidateRequest is false, then 'hello' is displayed<BR>&nbsp;&nbsp;&nbsp; // If ValidateRequest is true, then ASP.NET returns an exception<BR>&nbsp;&nbsp;&nbsp; Response.Write(txtString.Text);<BR>&nbsp; &#125;<BR>&nbsp;&lt;/script&gt;<BR>&nbsp;&lt;body&gt;<BR>&nbsp; &lt;form id="form1" runat="server"&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;asp:TextBox id="txtString" runat="server" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text="&lt;script&gt;alert('hello');&lt;/script&gt;" /&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;asp:Button id="btnSubmit" runat="server" OnClick="btnSubmit_Click" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text="Submit" /&gt;<BR>&nbsp; &lt;/form&gt;<BR>&nbsp;&lt;/body&gt;<BR>&lt;/html&gt;  </PRE></DIV><P>When you run the page, "Hello" is displayed in a message box because the script in <B>txtString</B> is passed through and rendered as client-side script in your browser.</P><P>If you set <B>ValidateRequest="true" </B>or remove the <B>ValidateRequest</B> page attribute, ASP.NET request validation rejects the script input and produces an error similar to the following.</P><DIV><PRE>A potentially dangerous Request.Form value was detected from the client (txtString="&lt;script&gt;alert('hello...").  </PRE></DIV><BLOCKQUOTE><B>Note</B>&nbsp;&nbsp;&nbsp;Do not rely on ASP.NET request validation. Treat it as an extra precautionary measure in addition to your own input validation.</BLOCKQUOTE><H1>Step 2. Constrain Input</H1><P>To constrain input, follow these guidelines: </P><UL><LI><B>Use server-side input validation.</B> Do not rely on client-side validation because it is easily bypassed. Use client-side validation in addition to server-side validation to reduce round trips to the server and to improve the user experience. <LI><B>Validate length, range, format and type.</B> Make sure that any input meets your guidelines for known good input. <LI><B>Use strong data typing. </B>Assign numeric values to numeric data types such as <B>Integer</B> or <B>Double</B>. Assign string values to string data types. Assign dates to the <B>DateTime</B> data type. </LI></UL><P>For Web form applications that obtain input through server controls, use the ASP.NET validator controls to constrain the input. For other sources of input data, such as query strings, cookies, and HTTP headers, constrain input by using the <B>Regex</B> class from the <B>System.Text.RegularExpressions</B> namespace.</P><H2>Explicitly Check Input from Form Fields</H2><P>To constrain form field input received through server controls, you can use the following ASP.NET validator controls: </P><UL><LI><B>RegularExpressionValidator.</B> Use this control to constrain text input. <LI><B>RangeValidator.</B> Use this control to check the ranges of numeric, currency, date, and string input. <LI><B>CustomValidator.</B> Use this control for custom validation, such as ensuring that a date is in the future or in the past. </LI></UL><P>To validate form field input received through HTML input controls, perform validation in server-side code and use the <B>Regex</B> class to help constrain text input. The following sections describe how to constrain a variety of common input types.</P><H3>Validating Text Fields </H3><UL><LI>To validate text fields, such as names, addresses, and tax identification numbers, use regular expressions to do the following: <LI>Constrain the acceptable range of input characters. <LI>Apply formatting rules. For example, pattern-based fields, such as tax identification numbers, ZIP Codes, or postal codes, require specific patterns of input characters. <LI>Check lengths. </LI></UL><H3>Using a RegularExpressionValidator</H3><P>To use a <B>RegularExpressionValidator</B>, set the <B>ControlToValidate</B>, <B>ValidationExpression</B>, and <B>ErrorMessage </B>properties to appropriate values as shown in the following example.</P><DIV><PRE>&lt;form id="WebForm" method="post" runat="server"&gt;<BR>&nbsp; &lt;asp:TextBox id="txtName" runat="server"&gt;&lt;/asp:TextBox&gt;<BR>&nbsp; &lt;asp:RegularExpressionValidator id="nameRegex" runat="server" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ControlToValidate="txtName" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationExpression="&#94;&#91;a-zA-Z'.\s&#93;&#123;1,40&#125;&#36;" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorMessage="Invalid name"&gt;<BR>&nbsp; &lt;/asp:regularexpressionvalidator&gt;<BR>&lt;/form&gt;  </PRE></DIV><P>The regular expression used in the preceding code example limits an input name field to alphabetic characters (lowercase and uppercase), space characters, the single apostrophe for names such as O'Dell, and the period. In addition, the field length is constrained to 40 characters.</P><BLOCKQUOTE><B>Note</B>&nbsp;&nbsp;&nbsp;The <B>RegularExpressionValidator</B> control automatically adds a caret (&#94;) and dollar sign (&#36;) as delimiters to the beginning and end of expressions if you have not added them yourself. You should add them to all of your regular expressions as good practice. Enclosing the expression in the delimiters ensures that the expression consists of the desired content and nothing else.</BLOCKQUOTE><H3>Using the Regex Class</H3><P>If you are not using server controls (which means you cannot use the validator controls), or you need to validate input from sources other than form fields (such as from query string parameters or cookies), you can use a <B>Regex</B> class.</P><P><B>To use the Regex class</B> </P><OL><LI>Add a <B>using</B> statement to reference the<B> System.Text.RegularExpressions</B> namespace. <LI>Ensure that the regular expression is contained in the &#94; and &#36; anchor characters (beginning of string, end of string). <LI>Call the <B>IsMatch</B> method of the <B>Regex</B> class, as shown in the following code example. </LI></OL><DIV><PRE>// Instance method:<BR>Regex reg = new Regex(&#64;"&#94;&#91;a-zA-Z'.\s&#93;&#123;1,40&#125;&#36;");<BR>Response.Write(reg.IsMatch(txtName.Text));</PRE></DIV><PRE>// Static method:<BR>if (&#33;Regex.IsMatch(txtName.Text,&#64;"&#94;&#91;a-zA-Z'.\s&#93;&#123;1,40&#125;&#36;")) <BR>&#123;<BR>&nbsp; // Name does not match expression<BR>&#125;</PRE><P>If you cannot cache your regular expression for frequent use, you should use the static <B>IsMatch</B> method where possible for performance reasons, to avoid unnecessary object creation.</P><H3>Validating Numeric Fields</H3><P>In most cases, numeric fields should be checked for type and range. To validate the type and range of a numeric input field that uses a server control, you can use a <B>RangeValidator</B> control. The <B>RangeValidator</B> supports currency, date, integer, double, and string data types. </P><P>To use a <B>RangeValidator</B>, set the <B>ControlToValidate</B>, <B>Type</B>, <B>MinimumValue</B>, <B>MaximumValue</B>, and <B>ErrorMessage</B> properties to appropriate values as shown in the following example.</P><DIV><PRE>&lt;asp:RangeValidator <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID="RangeValidator1" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Runat="server" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorMessage="Invalid range. Number must be between 0 and 255."<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ControlToValidate="rangeInput" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MaximumValue="255" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MinimumValue="0" Type="Integer" /&gt;  </PRE></DIV><P>If you are not using a server control, you can validate a numeric range by converting the input value to an integer and then performing a range check. For example, to validate that an integer is valid, convert the input value to a variable of type <B>System.Int32</B> by using the <B>Int32.TryParse</B> method. This method returns <B>false</B> if the type conversion fails.</P><DIV><PRE>Int32 i;<BR>if (Int32.TryParse(txtInput.Text, out i) == false)<BR>&#123;<BR>&nbsp; // Conversion failed<BR>&#125;  </PRE></DIV><P>The following code shows how to perform a type and range check for an integer entered through an HTML text input control. </P><DIV><PRE>&lt;&#37;&#64; Page Language="C#" &#37;&gt;</PRE><PRE>&lt;script runat="server"&gt;</PRE><PRE>&nbsp; void Page_Load(object sender, EventArgs e)<BR>&nbsp; &#123;<BR>&nbsp;&nbsp;&nbsp; if (Request.RequestType == "POST")<BR>&nbsp;&nbsp;&nbsp; &#123;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Int32.TryParse(Request.Form&#91;"integerTxt"&#93;, out i) == true)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#123;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // TryParse returns true if the conversion succeeds<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((0 &lt;= i &amp;&amp; i &lt;= 255) == true)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#123;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write("Input data is valid.");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#125;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write("Input data is out of range");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#125;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write("Input data is not an integer");<BR>&nbsp;&nbsp;&nbsp; &#125;<BR>&nbsp; &#125;<BR>&nbsp;&nbsp; <BR>&lt;/script&gt;</PRE></DIV><PRE>&lt;html&gt;<BR>&nbsp; &lt;body&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;form id="form1" action="NumericInput.aspx" method="post"&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;div&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Enter an integer between 0 and 255:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input name="integerTxt" type="text" /&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input name="Submit" type="submit" value="submit" /&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/div&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;/form&gt;<BR>&nbsp; &lt;/body&gt;<BR>&lt;/html&gt;</PRE><H3>Validating Date Fields</H3><P>You need to validate that date fields are of the correct type. In most cases, you also need to check them for range, for example to validate that they are in the future or past. If you use a server control to capture an input date, and if you also need to validate that a date falls within a specific range, you can use a <B>RangeValidator</B> control with its <B>Type</B> field set to <B>Date</B>. This control lets you specify a range by using constant date values. If you need to validate a date range based on today's date, for example to validate that a date is in the future or the past, you can use a <B>CustomValidator</B> control.</P><P>To use a <B>CustomValidator</B> control to validate a date, set the <B>ControlToValidate</B> and <B>ErrorMessage</B> properties and the <B>OnServerValidate</B> event to point to a custom method containing your validation logic. The following sample .aspx page code shows this approach.</P><DIV><PRE>&lt;&#37;&#64; Page Language="C#" &#37;&gt;</PRE><PRE>&lt;script runat="server"&gt;</PRE><PRE>&nbsp;void ValidateDateInFuture(object source, ServerValidateEventArgs args)<BR>&nbsp;&#123;<BR>&nbsp;&nbsp; DateTime dt;</PRE></DIV><PRE>&nbsp;&nbsp; // Check for valid date and that the date is in the future<BR>&nbsp;&nbsp; if ((DateTime.TryParse(args.Value, out dt) == false) &#124;&#124; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (dt &lt;= DateTime.Today))<BR>&nbsp;&nbsp; &#123;<BR>&nbsp;&nbsp;&nbsp;&nbsp; args.IsValid = false;<BR>&nbsp;&nbsp; &#125;<BR>&nbsp;&#125;&nbsp;</PRE><PRE>&lt;/script&gt;</PRE><PRE>&lt;html&gt;<BR>&nbsp; &lt;body&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;form id="form1" runat="server"&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;div&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Label ID="Label1" Runat="server" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text="Future Date:"&gt;&lt;/asp:Label&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:TextBox ID="futureDatetxt" Runat="server"&gt;&lt;/asp:TextBox&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:CustomValidator <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID="CustomValidator1" Runat="server" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorMessage="Invalid date. Enter a date in the future."<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ControlToValidate="futureDatetxt"&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnServerValidate="ValidateDateInFuture"&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/asp:CustomValidator&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;br /&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Button ID="submitBtn" Runat="server" Text="Submit"&nbsp; /&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/div&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;/form&gt;<BR>&nbsp; &lt;/body&gt;<BR>&lt;/html&gt;<BR></PRE><BLOCKQUOTE><B>Note</B>&nbsp;&nbsp;&nbsp;The preceding code uses <B>DateTime.TryParse</B>, which is new to .NET Framework 2.0.</BLOCKQUOTE><H2>Sanitizing Free-Text Fields</H2><P>To <I>sanitize</I> input, you make untrusted input safe by preventing it from being treated as code. For example, if your application handles user input that it cannot constrain or reads data from a shared database, you might need to sanitize the data or make the output safe when you write it on your page. Sanitize data prior to output by using <B>AntiXSSLibrary.HtmlEncode</B>. </P><H2>Allowing Restricted HTML Input</H2><P>If your application needs to accept a range of HTML elements&#8212;for example through a rich text input field such as a comments field&#8212;turn off ASP.NET request validation and create a filter that allows only the HTML elements that you want your application to accept. A common practice is to restrict formatting to safe HTML elements such as &lt;<B>b</B>&gt; (bold) and &lt;<B>i</B>&gt; (italic). Before writing the data, HTML-encode it. This makes any malicious script safe by causing it to be handled as text, not as executable code. </P><H2>To allow restricted HTML input </H2><OL><LI>Disable ASP.NET request validation by the adding the <B>ValidateRequest="false"</B> attribute to the <B>&#64; Page</B> directive. <LI>Encode the string input with the <B>HtmlEncode</B> method. <LI>Use a <B>StringBuilder</B> and call its Replace method to selectively remove the encoding on the HTML elements that you want to permit. </LI></OL><P>The following .aspx page code shows this approach. The page disables ASP.NET request validation by setting <B>ValidateRequest="false"</B>. It HTML-encodes the input and selectively allows the &lt;<B>b</B>&gt; and &lt;<B>i</B>&gt; HTML elements to support simple text formatting. </P><DIV><PRE>&lt;&#37;&#64; Page Language="C#" ValidateRequest="false"&#37;&gt;</PRE><PRE>&lt;script runat="server"&gt;</PRE><PRE>&nbsp; void submitBtn_Click(object sender, EventArgs e)<BR>&nbsp; &#123;<BR>&nbsp;&nbsp;&nbsp; // Encode the string input<BR>&nbsp;&nbsp;&nbsp; StringBuilder sb = new StringBuilder(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AntiXSSLibrary.HtmlEncode(htmlInputTxt.Text));<BR>&nbsp;&nbsp;&nbsp; // Selectively allow&nbsp; and &lt;i&gt;<BR>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;b&amp;gt;", "&lt;b&gt;");<BR>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;/b&amp;gt;", "");<BR>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;i&amp;gt;", "&lt;i&gt;");<BR>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;/i&amp;gt;", "");<BR>&nbsp;&nbsp;&nbsp; Response.Write(sb.ToString());<BR>&nbsp; &#125;<BR>&lt;/script&gt;</PRE><PRE>&lt;html&gt;<BR>&nbsp; &lt;body&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;form id="form1" runat="server"&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;div&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:TextBox ID="htmlInputTxt" Runat="server" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextMode="MultiLine" Width="318px"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Height="168px"&gt;&lt;/asp:TextBox&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Button ID="submitBtn" Runat="server" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text="Submit" OnClick="submitBtn_Click" /&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/div&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;/form&gt;<BR>&nbsp; &lt;/body&gt;<BR>&lt;/html&gt;  </PRE></DIV><H2>Validate Query String Values</H2><P>Validate query string values for length, range, format, and type. You usually do this by using a combination of regular expressions to: </P><UL><LI>Constrain the input values. <LI>Set explicit range checks. <LI>Specify the explicit type checks performed by converting the input value to its equivalent .NET Framework type and handling any ensuing conversion errors. </LI></UL><P>The following code example shows how to use the <B>Regex</B> class to validate a name string passed on a query string. </P><DIV><PRE>void Page_Load(object sender, EventArgs e)<BR>&#123;<BR>&nbsp; if (&#33;System.Text.RegularExpressions.Regex.IsMatch(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Request.QueryString&#91;"Name"&#93;, &#64;"&#94;&#91;a-zA-Z'.\s&#93;&#123;1,40&#125;&#36;"))<BR>&nbsp;&nbsp;&nbsp; Response.Write("Invalid name parameter");<BR>&nbsp; else<BR>&nbsp;&nbsp;&nbsp; Response.Write("Name is " &#43; Request.QueryString&#91;"Name"&#93;);<BR>&#125;  </PRE></DIV><H2>Validate Cookie Values</H2><P>Values maintained in cookies, such as query string parameters, can easily be manipulated by a client. Validate cookie values in the same way as you would for query string parameters. Validate them for length, range, format, and type.</P><H2>Validate File and URL Paths</H2><P>If your application has to accept input file names, file paths, or URL paths, you need to validate that the path is in the correct format and that it points to a valid location within the context of your application. Failure to do this can result in attackers persuading your application into accessing arbitrary files and resources. </P><H3>Validating File Paths</H3><P>To prevent a malicious user manipulating your code's file operations, avoid writing code that accepts user-supplied file or path input. For example: </P><UL><LI>If you must accept file names as input, use the full name of the file by using <B>System.IO.Path.GetFileName</B>. <LI>If you must accept file paths as input, use the full file path by using <B>System.IO.Path.GetFullPath</B>. </LI></UL><H3>Using MapPath to Prevent Cross Application Mapping</H3><P>If you use <B>MapPath</B> to map a supplied virtual path to a physical path on the server, use the overload of <B>Request.MapPath</B> that accepts a <B>bool</B> parameter so that you can prevent cross-application mapping. The following code example shows this technique.</P><DIV><PRE>try<BR>&#123;<BR>&nbsp; string mappedPath = Request.MapPath( inputPath.Text, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Request.ApplicationPath, false);<BR>&#125;<BR>catch (HttpException)<BR>&#123;<BR>&nbsp; // Cross-application mapping attempted<BR>&#125;  </PRE></DIV><P>The final <B>false</B> parameter prevents cross-application mapping. This means that a user cannot successfully supply a path that contains <B>".."</B> to traverse outside of your application's virtual directory hierarchy. Any attempt to do this results in an exception of type <B>HttpException</B>.</P><P>If you use server controls, you can use the <B>Control.MapPathSecure</B> method to retrieve the physical path to which the virtual path is mapped. <B>Control.MapPathSecure</B> uses code access security and throws an <B>HttpException</B> if the server control does not have permissions to read the resulting mapped file. For more information, see <B>Control.MapPathSecure</B> in the .NET Framework SDK documentation.</P><H3>Using Code Access Security to Restrict File I/O</H3><P>An administrator can restrict an application's file I/O to its own virtual directory hierarchy by configuring the application to run with Medium trust. In this event, .NET code access security ensures that no file access is permitted outside of the application's virtual directory hierarchy.</P><P>You configure an application to run with Medium trust by setting the &lt;<B>trust</B>&gt; element in Web.config or Machine.config.</P><DIV><PRE>&lt;trust level="Medium" /&gt;  </PRE></DIV><H3>Validating URLs</H3><P>You can filter for a valid URL format using a regular expression, such as the following.</P><DIV><PRE>&#94;(?:http&#124;https&#124;ftp)://&#91;a-zA-Z0-9\.\-&#93;&#43;(?:\:\d&#123;1,5&#125;)?(?:&#91;A-Za-z0-9\.\;\:\&#64;\&amp;\=\&#43;\&#36;\,\?/&#93;&#124;&#37;u&#91;0-9A-Fa-f&#93;&#123;4&#125;&#124;&#37;&#91;0-9A-Fa-f&#93;&#123;2&#125;)&#42;&#36;  </PRE></DIV><P>This constrains the input, but it does not validate whether the URL is valid in terms of the application boundaries. You should check whether the target is valid in the context of your application. For example, does it point to an authorized server that you expect your application to communicate with?</P><H1>Step 3. Encode Unsafe Output</H1><P>If you write text output to a Web page, encode it using <B>AntiXSSLibrary.HtmlEncode</B>. Do this if the text came from user input, a database, or a local file. </P><P>Similarly, if you write URLs that might contain unsafe characters because they have been constructed from input data or data from a shared database, use <B>AntiXSSLibrary.UrlEncode</B> to make them safe. </P><P>Avoid the mistake of encoding the data early. Make sure you encode at the last possible opportunity before the data is displayed to the client. </P><P>Do not use the <STRONG>HttpUtilty </STRONG>class provided by ASP.NET as it does not do a complete job of protecting against cross site scripting attacks, the <STRONG>AntiXSSLibrary </STRONG>is much more effective.</P><H2>Use HtmlEncode to Encode Unsafe Output</H2><P>The <B>HtmlEncode</B> method replaces characters that have special meaning in HTML to HTML variables that represent those characters. For example, &lt; is replaced with <B>&amp;lt;</B> and <B>"</B> is replaced with <B>&amp;quot;</B>. Encoded data does not cause the browser to execute code. Instead, the data is rendered as harmless text, and the tags are not interpreted as HTML.</P><P>To illustrate the use of <B>HtmlEncode</B>, the following page accepts input from the user and allows potentially unsafe HTML characters by setting <B>ValidateRequest="false"</B>. Before writing the input back to the user, the code calls <B>AntiXSSLibrary.HtmlEncode</B> on the supplied input text. This renders any potentially unsafe HTML as harmless text. </P><DIV><PRE>&lt;&#37;&#64; Page Language="C#" ValidateRequest="false" &#37;&gt;</PRE><PRE>&lt;script runat="server"&gt;<BR>&nbsp; void submitBtn_Click(object sender, EventArgs e)<BR>&nbsp; &#123;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write(AntiXSSLibrary.HtmlEncode(inputTxt.Text));<BR>&nbsp; &#125;<BR>&lt;/script&gt;</PRE><PRE>&lt;html&nbsp; &gt;<BR>&nbsp; &lt;body&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;form id="form1" runat="server"&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;div&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:TextBox ID="inputTxt" Runat="server" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextMode="MultiLine" Width="382px" Height="152px"&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/asp:TextBox&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Button ID="submitBtn" Runat="server" Text="Submit" <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnClick="submitBtn_Click" /&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/div&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;/form&gt;<BR>&nbsp; &lt;/body&gt;<BR>&lt;/html&gt;  </PRE></DIV><P>To see the effect of the HTML encoding, place the preceding page in a virtual directory, browse to it, enter some HTML code in the input text box, and click <B>Submit</B>. For example, the following input is rendered as text.</P><DIV><PRE>Run script and say hello &lt;script&gt;alert('hello');&lt;/script&gt;  </PRE></DIV><P>It produces the following safe output.</P><DIV><PRE>Run script and say hello &lt;script&gt;alert('hello');&lt;/script&gt;  </PRE></DIV><P>If you remove the call to <B>HtmlEncode</B> and simply write back the input, the browser executes the script and displays a message box. Malicious script could pose a significant threat. </P><H2>Use UrlEncode to Encode Unsafe URLs</H2><P>If you need to write URLs that are based on input that you do not fully trust, use <B>AntiXSSLibrary.UrlEncode</B> to encode the URL string.</P><DIV><PRE>AntiXSSLibrary.UrlEncode( urlString );  </PRE></DIV><H1>Step 4. Use Command Parameters for SQL Queries</H1><P>To help prevent SQL injection, use command parameters for SQL queries. The <B>Parameters</B> collection provides type checking and length validation. If you use the <B>Parameters</B> collection, input is treated as a literal value and SQL does not treat it as executable code. An additional benefit of using the <B>Parameters</B> collection is that you can enforce type and length checks. Values outside of the range trigger an exception.</P><H2>Use Parameters Collection When You Call a Stored Procedure</H2><P>The following code fragment illustrates the use of the <B>Parameters</B> collection when calling a stored procedure.</P><DIV><PRE>SqlDataAdapter myCommand = new SqlDataAdapter("AuthorLogin", <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myConnection);<BR>myCommand.SelectCommand.CommandType = CommandType.StoredProcedure;<BR>SqlParameter parm = myCommand.SelectCommand.Parameters.Add(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&#64;LoginId", SqlDbType.VarChar, 11);<BR>parm.Value = Login.Text;  </PRE></DIV><H2>Use Parameters Collection When Building Your SQL Statements</H2><P>If you cannot use stored procedures, you can still use parameters, as shown in the following code fragment.</P><DIV><PRE>SqlDataAdapter myCommand = new SqlDataAdapter(<BR>"SELECT au_lname, au_fname FROM Authors WHERE au_id = &#64;au_id", myConnection);<BR>SQLParameter parm = myCommand.SelectCommand.Parameters.Add(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&#64;au_id" ,SqlDbType.VarChar, 11);<BR>Parm.Value = Login.Text;  </PRE></DIV><P>For more information about how to prevent SQL injection, see <A href="http://msdn2.microsoft.com/en-us/library/ms998271.aspx">How to: Protect From SQL Injection in ASP.NET</A>.</P><H1>Step 5. Verify that ASP.NET Errors Are Not Returned to the Client</H1><P>You can use the &lt;<B>customErrors</B>&gt; element to configure custom, generic error messages that should be returned to the client in the event of an application exception condition.</P><P>Make sure that the <B>mode</B> attribute is set to <B>"remoteOnly"</B> in the web.config file as shown in the following example.</P><DIV><PRE>&lt;customErrors mode="remoteOnly" /&gt;  </PRE></DIV><P>After installing an ASP.NET application, you can configure the setting to point to your custom error page as shown in the following example.</P><DIV><PRE>&lt;customErrors mode="On" defaultRedirect="YourErrorPage.htm" /&gt;  </PRE></DIV><HR><P>Adapted from Microsoft patterns &amp; practices guidance.</P>

]]></content></guidanceItem>