<?xml version="1.0" encoding="utf-8"?><guidanceItem id="5785aae6-b3d7-47d7-ab4e-31be81f29caf" type="guideline" title="Store Passwords Securely" cssFile="guidance.css" Date="2010-12-30T00:19:11.1875Z" Author="" Category="Authentication" filePath="..\Libraries\OWASP\Guideline\5785aae6-b3d7-47d7-ab4e-31be81f29caf.xml" Priority="2" Rule_Type="Implementation" Source="SI" Status="" Technology="Java" Topic="Security" Type="Guideline" xmlns="urn:microsoft:guidanceexplorer:guidanceItem"><content><![CDATA[<H1>Applies to</H1><UL><LI>Applications written using Servlets or JSP.</LI></UL><H1>What to Do</H1><P>Store passwords in a secure fashion. Do not store in plain text or use an easy-to-crack encryption or obfuscation scheme.</P><H1>Why</H1><P>Storing passwords in plaintext or using weak encryption can aid an attacker when stealing them. Compromised passwords may aid an attacker into accessing, modifying and deleting sensitive data.</P><H1>When</H1><P>This guideline should be followed only if your application requires that you store passwords. This may be necessary if, for instance, your application must retrieve the original password at some point. Otherwise, follow the <A href="ruledisplay:9AE15BFD-0C19-4539-A77A-BB1ADF93CA9A">Do Not Store Passwords</A> guideline.</P><H1>How</H1><P>Use the following steps to store passwords securely:</P><OL><LI><P><STRONG>Choose user-identifiable data. </STRONG>User-identifiable data will be used to generate a secure key. This data should be tied to the user's account, and it should be different for every user. For example, a valid email address would fit into this category. If your application uses the email address approach, confirm that the address is real and verify that no&nbsp;two users are sharing an email address.</P><LI><P><STRONG>Generate the&nbsp;key. </STRONG>Use the user-identifiable data and some random salt to generate the key. Because encryption key sizes need to be 256 bit, it is recommended to generate the key by hashing the user-identifiable data with some random salt. This technique makes it impossible for an attacker to obtain the encryption key&nbsp;unless he also&nbsp;obtains your application's random salt.<BR><BR>Make sure that you securely clean-up all instances of the generated encryption key as it can help an attacker compromise the protected password if the key is exposed. Consult the <A href="ruledisplay:E5D7DA05-EB59-46C5-AF9F-BA1B32C783CE">Clear Sensitive Data from Memory when No Longer Used</A> guideline for more details. Example of generating an encryption key:</P><BLOCKQUOTE><PRE>byte&#91;&#93; salt = MyApp.generateSalt();<BR>String userMail = <A href="mailto:myapp&#64;example.com">myapp&#64;example.com</A>;<BR>MessageDigest md = MessageDigest.getInstance("SHA-512");<BR>md.update(userMail.getBytes("UTF-8"));<BR>md.update(salt);<BR>byte&#91;&#93; rawKey = md.digest();<BR>md.reset();</PRE></BLOCKQUOTE><P>If your application uses a randomly generated salt, make sure that your application encrypts the random salt and stores it into a configuration file. Always use <STRONG>SecureRandom</STRONG> and not <STRONG>Random</STRONG> to generate the salt. Example of using <STRONG>SecureRandom</STRONG> to generate a random salt:</P><BLOCKQUOTE><PRE>public static byte&#91;&#93; generateSalt() throws NoSuchAlgorithmException<BR>&#123;<BR>      // Note that salt is declared as private static byte&#91;&#93; and is<BR>      // initialized to null.<BR>       if (salt == null)<BR>      &#123;<BR>            SecureRandom srand = SecureRandom.getInstance("SHA1PRNG");<BR>                          salt = new byte&#91;4&#93;;<BR>            srand.nextBytes(salt);<BR>      &#125;<BR>       return salt;<BR>&#125;</PRE></BLOCKQUOTE><P>For more information, consult the documentation for <A href="http://java.sun.com/j2se/1.4.2/docs/api/java/security/SecureRandom.html">SecureRandom Class</A> in the Java SDK.</P><LI><P><STRONG>Choose an&nbsp;appropriate encryption function. </STRONG>Choose a strong symmetric encryption algorithm that will not be easy for an attacker to break such as AES.</P><BLOCKQUOTE><PRE>byte&#91;&#93; salt = MyApp.generateSalt();<BR>String userMail = <A href="mailto:myapp&#64;example.com">myapp&#64;example.com</A>;<BR>MessageDigest md = MessageDigest.getInstance("SHA-512");<BR>md.update(userMail.getBytes("UTF-8"));<BR>md.update(salt);<BR>byte&#91;&#93; rawKey = md.digest();<BR>md.reset();<BR>SecretKeySpec skeySpec = new SecretKeySpec(rawKey, "AES");<BR>// Set up cipherCipher cipher = Cipher.getInstance("AES");<BR>cipher.init(Cipher.ENCRYPT_MODE, skeySpec);<BR>// Note that pass is declared as byte&#91;&#93; and contains the user's password<BR>byte&#91;&#93; encrypted = cipher.doFinal(pass);</PRE></BLOCKQUOTE><P>Because of import control restrictions, Java initially ships with a limited set of cryptography. To fully utilize Java's crypto strength, it is recommended to install the "Unlimited Strength" <A href="http://java.sun.com/products/jce/index-14.html">Jurisdiction Policy Files</A>.</P></LI></OL><P><STRONG>Note:</STRONG> Never store the user credentials or their encrypted values on the client side (e.g. in cookies, hidden fields, etc.). Use sessions when there is a need to track the user or to&nbsp;store their encrypted credentials. For more information, consult the Session Management section.</P><H1>Problem Example</H1><P>The following code authenticates a user based on a username and password. The supplied credentials are compared to the credentials stored in the backend database. Unfortunately, the credentials in the database are in plaintext and could be stolen if the database is compromised.</P><BLOCKQUOTE><PRE>public boolean validateUser(String user, char&#91;&#93; pass)<BR>&#123;<BR>      // Query the credential store with the provided credentials<BR>      ...<BR>&#125;</PRE></BLOCKQUOTE><H1>Solution Example</H1><P>The following code validates the user based on a&nbsp;given username and password. It uses the user's valid email address and a random salt to encrypt the user's password. Then it compares the username and the produced digest against the data stored in the backend database. Therefore, the password is stored encrypted in the database.</P><BLOCKQUOTE><PRE>public boolean validateUser(String user, char&#91;&#93; pass)<BR>&#123;<BR>       ...<BR>       // Encrypt the credentials<BR>      try<BR>      &#123;<BR>            userEmail = MyApp.getEmailForUser(user);<BR>            passDigest = encryptCredentials(userEmail, pass, salt);<BR>      &#125;<BR>      catch (GeneralSecurityException gse)<BR>      &#123;<BR>            // Add the appropriate logging and exception handling mechanisms<BR>             <BR>            return false;<BR>      &#125;<BR>      catch (IOException ioe)<BR>      &#123;<BR>            // Add the appropriate logging and exception handling mechanisms<BR>            return false;<BR>      &#125;<BR>       // Query the credential store and execute the rest of the authentication steps<BR>      ...<BR>&#125;<BR>public static byte&#91;&#93; encryptCredentials(String email, char&#91;&#93; pass, byte&#91;&#93; salt)<BR>       throws GeneralSecurityException, IOException<BR>&#123;<BR>      MessageDigest md;<BR>      byte&#91;&#93; tempPass;<BR>      byte&#91;&#93; rawKey;<BR>      // Generate encryption key<BR>      md = MessageDigest.getInstance("SHA-512");<BR>      md.update(email.getBytes("UTF-8"));<BR>      md.update(salt);<BR>      rawKey = md.digest();<BR>      md.reset();<BR>      SecretKeySpec skeySpec = new SecretKeySpec(rawKey, "AES");<BR>      // Set up cipher<BR>      Cipher cipher = Cipher.getInstance("AES");<BR>      cipher.init(Cipher.ENCRYPT_MODE, skeySpec);<BR>      // Convert char&#91;&#93; to byte&#91;&#93;<BR>      tempPass = new byte&#91;pass.length&#93;;<BR>      for (int i = 0; i &lt; pass.length; i&#43;&#43;)<BR>      &#123;<BR>            tempPass&#91;i&#93; = (byte)pass&#91;i&#93;;<BR>      &#125;<BR>      // Encrypt password<BR>      byte&#91;&#93; encrypted = cipher.doFinal(tempPass);<BR>            //Clean tempPass<BR>      for (int i = 0; i &lt; tempPass.length; i&#43;&#43;)<BR>      &#123;<BR>            tempPass&#91;i&#93; = 0;<BR>      &#125;<BR>      return encrypted;<BR>&#125;</PRE></BLOCKQUOTE><H1>Additional Resources</H1><UL><LI>To learn more about the JCE API, see: <A href="http://download.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html">Java Cryptography Extension for the Java 2 SDK, v 1.4</A>. <LI>For more information about securely generating random numbers, see: Documentation for <A href="http://download.oracle.com/javase/1.4.2/docs/api/java/security/SecureRandom.html">Class SecureRandom</A> in Java SDK.</LI></UL><H1>Related Items</H1><UL><LI><A href="ruledisplay:9AE15BFD-0C19-4539-A77A-BB1ADF93CA9A">Guideline: Do Not Store Passwords (Java Web Application)</A> <LI><A href="ruledisplay:E5D7DA05-EB59-46C5-AF9F-BA1B32C783CE">Guideline: Clear Sensitive Data from Memory when No Longer Used (Java Web Application)</A> <LI><A href="ruledisplay:8EDBAC9F-BFCF-43DF-A4FA-5BB7E03E7410">Guideline: Do Not Leave Passwords in Memory (Java Web Application)</A> <LI><A href="ruledisplay:3B657A67-F660-4DB5-9267-6E0FE2DAA1EB">Attack: Chosen Ciphertext Attack</A> <LI><A href="ruledisplay:DEBB5734-39D0-4922-BDEE-1E0547E22DAD">Attack: Chosen Plaintext Attack</A> <LI><A href="ruledisplay:44E50CB3-9B24-4BC3-8CBA-73112F3C11BF">Checklist Item: Passwords are Stored Securely (Java Web Application)</A> </LI></UL>
]]></content></guidanceItem>