<?xml version="1.0" encoding="utf-8"?><guidanceItem id="c2651adf-f0d8-4067-b3fc-0c8b0cb315f4" type="guideline" title="Validate Input from All Sources For Type, Length, Format, and Range" cssFile="guidance.css" Date="2010-10-03T06:00:02.78125Z" Author="" Category="Input and Data Validation" filePath="..\Libraries\OWASP\Guideline\c2651adf-f0d8-4067-b3fc-0c8b0cb315f4.xml" Priority="2" Rule_Type="Implementation" Source="SI" Status="" Technology="ASP.NET 3.5" Topic="Security" Type="Guideline" xmlns="urn:microsoft:guidanceexplorer:guidanceItem"><content><![CDATA[<H1>What to Do</H1><P>Do not trust input.&nbsp; Instead, validate on the server that it matches the expected input, be careful which contexts you allow it to be used in, and encode it appropriately on output. </P><H1>Why</H1><P>An attacker passing malicious input can attempt SQL injection, cross-site scripting, and other injection attacks that aim to exploit your application's vulnerabilities.&nbsp; Validating input helps to reduce these risks by ensuring that the input received matches the expected format.&nbsp;Input validation on it's own is not sufficient; output encoding is also needed to fully prevent these attacks, but it is an important step for both security and reliability. </P><H1>When</H1><P>All input should always be validated, regardless of source.&nbsp; Unless data is actually static within the scope of the local code base, it could be modified by a malicious user&#8212;even data in a database which is supposed to be static.&nbsp; </P><H1>How</H1><OL><LI><P><STRONG>Where to Validate Data.</STRONG> Input must be validated on the server for security checks.&nbsp; While it can be useful for user experience reasons to check the input on the client side, especially on things like web applications with high round-trip latencies, this client-side validation is not sufficient to provide security guarantees, as it can be circumvented by the attacker. </P><LI><P><STRONG>What Data to Validate.</STRONG> Check for known good data and constrain input by validating it for type, length, format, and range.&nbsp; For Web form applications that obtain input through server controls, use the ASP.NET validator controls, such as the RegularExpressionValidator, RangeValidator, and CustomValidator, to validate and constrain input.&nbsp; All input not under control of the system should be validated, but input coming directly from users must be validated and should receive the most attention.&nbsp; </P><LI><P><STRONG>How to Implement Validation.</STRONG> Most Web applications accept input from various sources, including HTML controls, server controls, query strings, and cookies.&nbsp; Validate input from all of these sources to help prevent injection attacks.&nbsp; Use regular expressions to help validate input.&nbsp; The following example shows how to use the Regex class. </P><PRE>using System.Text.RegularExpressions;<BR>// Instance method:Regex reg = new Regex(&#64;"&#94;&#91;a-zA-Z'.\s&#93;&#123;1,40&#125;&#36;");<BR>Response.Write(reg.IsMatch(Request.QueryString&#91;"Name"&#93;));<BR>// Static method:<BR>if (&#33;Regex.IsMatch(Request.QueryString&#91;"Name"&#93;,&#64;"&#94;&#91;a-zA-Z'.\s&#93;&#123;1,40&#125;&#36;"))<BR>&#123;<BR>   // Name does not match expression<BR>&#125;</PRE><P>If you cannot cache your regular expression for frequent use, you should use the static IsMatch method where possible for performance reasons, to avoid unnecessary object creation. </P><P>In general, validate your input against the least permissive expression possible that will accept all the input you expect for that field.&nbsp; If you know that the field will have certain internal structure, check for it.&nbsp; If there is a range of standard formats which your users may enter data in, but these formats are easily converted to a single internal format, do so.&nbsp; </P><P><STRONG>Note:</STRONG>&nbsp;&nbsp;&nbsp; Validating input does not remove the need to format output, parametrize queries, or otherwise handle user input carefully. </P><LI><P><STRONG>Validating Specific Data Types.</STRONG> Specific data types allow for and require different types of checks.&nbsp; Here are some guidelines for common data types:</P><UL><LI><P><STRONG>Numeric Data.</STRONG> Check all numeric fields for type and range. If you are not using server controls, you can use regular expressions and the Regex class, and you can validate numeric ranges by converting the input value to an integer or double, ensuring the conversion was valid,&nbsp;and then performing a range check.&nbsp; If your input has an internal checksum, like a credit card number, check that too.</P><LI><P><STRONG>Address Data.</STRONG> Address data has a fairly rich internal structure; the more of this structure your validation routine understands, the better you'll be able to validate the information.&nbsp; Phone numbers can be validated as a string of ten digits, or a variable number of digits beginning with the character '&#43;' if international numbers are allowed.&nbsp; If needed, the country code can be determined and the exact number format looked up.&nbsp; While phone numbers are written several different ways,&nbsp;a canonical representation can be created by stripping all non-numeric characters before validation, something which will save your users time and frustration as they enter data into your site.&nbsp; Street addresses require a little bit more care; if the input is taken in divided into street, city, etc., each field can have a seperate safe character set defined--city names don't need numbers, for instance.&nbsp; Names are fairly straightforward, but are one of the cases where the "'" character is valid input, and thus they must be handled appropriately (as all input should be) at the database level.&nbsp; Also, don't forget to allow accented characters in names and addresses, depending on your current code page.</P><LI><P><STRONG>Reference Data. </STRONG>Data that refers to other things can go through one final step of validation, namely looking up what it refers to to insure that the reference is valid.&nbsp; For instance, postal codes can be validated against a canonical list to ensure correctness, and other aspects of the street address cross-checked with that.&nbsp; In an order management system, item IDs can be&nbsp;checked against a list of valid IDs.</P></LI></UL></LI></OL><H1>Problem Example</H1><P>An order form for a web store has several fields, specifically, a name, address, phone number, item number, and quantity.&nbsp; Each item is simply added to the database with no data validation and all typecasting handled by the database.&nbsp; Typecasting in the database does not prevent SQL injection and has little effect on out of range data.&nbsp; An attacker can perform numerous attacks, from something as benign as filling the database with garbage data to more actively destructive SQL injection and cross-site scripting attacks.</P><H1>Solution Example</H1><P>An ASP.NET application contains an order for for a web store.&nbsp; Each of the forms fields are validated, giving stronger guarantees about the data gathered.&nbsp; The phone number&nbsp;is validated as a string of ten digits (after stripping all non-numeric characters), or a variable number of digits beginning with the character '&#43;' if international numbers are allowed.&nbsp; </P><P>Validating a name, address, and item number can all be a bit more complicated.&nbsp; The first order of business is determining the legal character set for each case.&nbsp; For names, spaces, upper and lower case letters (including the accented forms for your current codepage), and possible numbrs and periods are enough.&nbsp; Addresses need to add commas, hyphens, and number signs, at a minimum.&nbsp; Validating item numbers may be as simple as casting to an integer and checking that the result is in the right range, or it may mean a more complicated regular expression that checks for internal formatting in a string. </P><P>The last, optional step of data validation is to ensure that the data refers to a valid things.&nbsp; The data should be validated for format first, especially as further checks may require database queries.&nbsp; Item numbers are an obvious thing to check for existence in the DB, and this would normally happen as part of the stored procedure which creates a new order, but names, addresses, and phone numbers can be similarly checked, some times.&nbsp; For example, if the address field is broken up into components, state or province information, zip/post codes, and city names, at a minimum, can all be validated against existing lists.</P><HR><P>Adapted from Microsoft patterns &amp; practices guidance. </P>
]]></content></guidanceItem>