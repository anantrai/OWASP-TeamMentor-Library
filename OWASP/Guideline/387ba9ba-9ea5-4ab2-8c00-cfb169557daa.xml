<?xml version="1.0" encoding="utf-8"?><guidanceItem id="387ba9ba-9ea5-4ab2-8c00-cfb169557daa" type="guideline" title="Use Type Safe SQL Parameters when Constructing SQL Queries" cssFile="guidance.css" Date="2010-09-22T16:47:05.96875Z" Author="" Category="Data Access" filePath="..\Libraries\OWASP\Guideline\387ba9ba-9ea5-4ab2-8c00-cfb169557daa.xml" Priority="1" Rule_Type="Implementation" Source="SI" Status="" Technology="ASP.NET 3.5" Topic="Security" Type="Guideline" xmlns="urn:microsoft:guidanceexplorer:guidanceItem"><content><![CDATA[<H1>What to Do</H1><P>Use type-safe parameters when constructing dynamic SQL queries or when passing parameters to stored procedures. </P><H1>Why</H1><P>If you use the Parameters collection, SQL treats the input is as a literal value rather then as executable code. The Parameters collection can be used to enforce type and length constraints on input data. Values outside of the range trigger an exception. If type safe SQL parameters are not used, attackers might be able to execute injection attacks that are embedded in the unfiltered input.</P><H1>When</H1><P>This guideline is applicable whenever there is an SQL statement that is built dynamically. It is also appropriate whenever stored procedures are utilized.</P><H1>How</H1><P>One way of making the application less susceptible to SQL injection attacks is by using stored procedures. Stored procedures are subroutines stored in the database that are available to applications for accessing the data. </P><P>Just using stored procedures isn't a complete remedy for SQL injection. The important thing to do is use parameters with stored procedures, else, your stored procedures can be susceptible to SQL injection if they use unfiltered input. Stored procedures provide several security advantages:</P><UL><LI>By parameterizing input parameters and type enforcing them, user input is effectively filtered <LI>Stored procedures are allowed to execute under different security privileges from the database user by most databases, thereby restricting the ability of the application to do anything beyond the actions specified in the stored procedures. For instance, an application would have execute access to a stored procedure, but no access to the base tables.</LI></UL><P>To use type safe SQL parameters, follow these steps:</P><OL><LI><P><STRONG>If possible, use stored procedures.</STRONG> Stored procedures are pre-compiled statements that are stored on the database server. Using stored procedures improves your application's performance and security. Consult the <A href="ruledisplay:8F360E73-D932-4512-84B4-2D7A6632DA7F">Use Stored Procedures</A> guideline for more details.</P><LI><P><STRONG>Determine the parameters in the SQL query or stored procedure being constructed.</STRONG> All parameters that result from user input or another untrusted source should be escaped, by specifying variable names in the query:</P><PRE>SELECT &#42; from books WHERE ISBN = '&#64;isbn'</PRE><LI><P><STRONG>Declare the explicit data types for each parameter in the SQL statement.</STRONG> When executing the SQL statement, specify the data type and length for each parameter in the query:</P><PRE>myCommand.SelectCommand.Parameters.Add("&#64;isbn", SqlDbType.VarChar, 10);</PRE><LI><P><STRONG>Specify the value for each parameter.</STRONG> The untrusted input is then specified, so that it can be properly handled when the SQL statement executes:</P><PRE>myCommand.SelectCommand.Parameters&#91;"&#64;isbn"&#93;.Value = '0494483923';</PRE></LI></OL><H1>Problem Example</H1><P>Consider an ASP.NET application that handles employee payroll functionality for a small company. One of the pages requires retrieving an employee record from a table based on a username and password supplied via a login dialog. The developer of the application created an SQL SELECT query to accomplish said task:</P><PRE>using (SqlConnection myConnection = new SqlConnection(connectionString))<BR><PRE>SqlConnection myConnection = new SqlConnection("Data Source=localhost\\sqlexpress;<BR>&#9;&#9;&#9;&#9;&#9;&#9;Initial Catalog=EmployeePayroll;<BR>&#9;&#9;&#9;&#9;&#9;&#9;Integrated Security=True");<BR>string SQLstr = "SELECT &#42; from users WHERE username = '" &#43; un.Text &#43; <BR>&#9;&#9;&#9;&#9;&#9;&#9;&#9;"' AND password = '" &#43; <BR>&#9;&#9;&#9;&#9;&#9;&#9;&#9;pass.Text &#43; "'";</PRE><PRE>SqlCommand myCommand = new SqlCommand(SQLstr, myConnection);</PRE><PRE>SqlDataAdapter myDataAdapter = new SqlDataAdapter(myCommand);</PRE><PRE>myCommand.Connection.Open();</PRE><PRE>SqlDataReader myReader = myCommand.ExecuteReader();<BR></PRE></PRE><P>In the preceding example, the SELECT statement will work as expected, assuming that the input is perfectly constrained. However, what happens if a user enters unexpected input such as '1234' for a password, and this for a username:</P><PRE>mjones' AND 1=1; -- </PRE><P>This will result in the SQL statement being executed at the database level:</P><PRE>SELECT &#42; from users WHERE username = 'mjones' AND 1=1; --'  AND password = '1234';</PRE><P>This will allow the person entering data into the dialog box to select the account details of mjones without the correct password.</P><H1>Solution Example</H1><P>Consider an ASP.NET application that handles employee payroll functionality for a small company. One of the pages requires retrieving an employee record from a table based on a username and password supplied via a login dialog. The developer of the application uses the following SQL query to take advantage of type safe parameters with the SqlParameterCollection when constructing the query dynamically:</P><PRE><PRE>using System.Data;<BR>using System.Data.SqlClient;</PRE><PRE>using (SqlConnection connection = new SqlConnection(connectionString))<BR>&#123;<BR>&nbsp; DataSet userDataset = new DataSet();<BR>&nbsp; SqlDataAdapter myDataAdapter = new SqlDataAdapter(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SELECT &#42; from users WHERE username = <A href="mailto:'&#64;uname'">'&#64;uname'</A> AND password = <A href="mailto:'&#64;pwd'">'&#64;pwd'</A>", connection);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp; myCommand.SelectCommand.Parameters.Add("&#64;uname", SqlDbType.VarChar, 24);<BR>&nbsp; myCommand.SelectCommand.Parameters.Add("&#64;pwd", SqlDbType.VarChar, 16);</PRE><PRE>  myCommand.SelectCommand.Parameters&#91;"&#64;uname"&#93;.Value = un.Text;</PRE><PRE>  myCommand.SelectCommand.Parameters&#91;"&#64;pwd"&#93;.Value = pass.Text;<BR><BR>&nbsp; myDataAdapter.Fill(userDataset);<BR>&#125;<BR></PRE></PRE><P>In the preceding code example, the input values are constrained for length and escaped. If the data does not conform to the type or length defined by the parameter, the SqlParameter class throws an exception.</P><H1>Additional Resources</H1><UL><LI>To learn more about SQL injection, see: <A href="http://en.wikipedia.org/wiki/SQL_injection">SQL Injection</A> in Wikipedia. <LI>To learn more about countering SQL injection in ASP.NET, visit: <A href="http://msdn2.microsoft.com/en-us/library/ms998271.aspx">How To: Protect From SQL Injection in ASP.NET</A>. <LI>To learn more about countering injection-based attacks in ASP.NET, see: <A href="http://msdn2.microsoft.com/en-us/library/bb355989.aspx">How To: Protect From Injection Attacks in ASP.NET</A>.</LI></UL><H1>Related Items</H1><UL><LI><A href="ruledisplay:F1B74837-9A72-4745-A149-EC5D8C476EB7">Guideline: Validate All Input Passed to Database </A><LI><A href="ruledisplay:8F360E73-D932-4512-84B4-2D7A6632DA7F">Guideline: Use Stored Procedures </A><LI><A href="ruledisplay:8515588C-661A-4962-853F-6CD6ABCD8CF6">Attack: Server-Side Code Injection Attack</A> <LI><A href="ruledisplay:22BE1EE0-7DA4-4571-8D58-3ED211A05947">Checklist Item: Type Safe SQL Parameters are Used </A></LI></UL><HR><P>Adapted from Microsoft patterns &amp; practices guidance. </P>
]]></content></guidanceItem>