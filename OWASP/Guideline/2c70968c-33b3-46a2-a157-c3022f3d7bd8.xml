<?xml version="1.0" encoding="utf-8"?><guidanceItem id="2c70968c-33b3-46a2-a157-c3022f3d7bd8" type="guideline" title="Avoid Dynamic Queries that Accept User Input" cssFile="guidance.css" Date="2010-10-03T05:04:56.640625Z" Author="" Category="Data Access" filePath="..\Libraries\OWASP\Guideline\2c70968c-33b3-46a2-a157-c3022f3d7bd8.xml" Priority="2" Rule_Type="Implementation" Source="SI" Status="" Technology="ASP.NET 3.5" Topic="Security" Type="Guideline" xmlns="urn:microsoft:guidanceexplorer:guidanceItem"><content><![CDATA[<H1>What to Do</H1><P>Avoid constructing SQL queries in code that include user input; instead, prefer parameterized stored procedures that use type safe SQL parameters.&nbsp;If stored procedures&nbsp;cannot be used, use parameterized dynamic SQL statements.</P><H1>Why</H1><P>Database queries constructed dynamically&nbsp;from user input&nbsp;are susceptible to SQL injection. A successful SQL injection attack enables a malicious user to execute commands&nbsp;on the&nbsp;application's database instance by using the privileges granted to&nbsp;the application's login. Using stored procedures with parameterized SQL is recommended because SQL parameters are type safe&nbsp;and treated as&nbsp;literal values by the database,&nbsp;not as executable code. Parameters are also checked for type and length. </P><H1>When</H1><P>Always use parameterized SQL queries. Avoid constructing SQL queries directly from&nbsp;any input, including form fields, query string parameters, and cookies.&nbsp;&nbsp;</P><H1>How</H1><P>To protect&nbsp;an application from SQL injection, perform the following steps:</P><OL><LI><P><STRONG>Use parameters with stored procedures.</STRONG> Stored procedures alone&nbsp;will not prevent SQL injection.&nbsp;Lack&nbsp;of&nbsp;parameter usage means that&nbsp;stored procedures will be susceptible to SQL injection, especially if they use unfiltered input. The following code shows how to use SqlParameterCollection when calling a stored procedure:</P><PRE>using System.Data;<BR>using System.Data.SqlClient;</PRE><PRE>using (SqlConnection connection = new SqlConnection(connectionString))<BR>&#123;<BR>&nbsp; DataSet userDataset = new DataSet();<BR>&nbsp; SqlDataAdapter myCommand = new SqlDataAdapter( <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "LoginStoredProcedure", connection);<BR>&nbsp; myCommand.SelectCommand.CommandType = CommandType.StoredProcedure;<BR>&nbsp; myCommand.SelectCommand.Parameters.Add("&#64;au_id", SqlDbType.VarChar, 11);<BR>&nbsp; myCommand.SelectCommand.Parameters&#91;"&#64;au_id"&#93;.Value = AuthId.Text;</PRE><PRE>&nbsp; myCommand.Fill(userDataset);<BR>&#125;</PRE><P>In this case, the &#64;au_id parameter is treated as a literal value and not as executable code. Also, the parameter is checked for type and length. In the preceding code example, the input value cannot be longer than 11 characters. If the data does not conform to the type or length defined by the parameter, the SqlParameter class throws an exception.</P><LI><P><STRONG>Use parameters with dynamic SQL.</STRONG> If stored procedures are unavailable, use parameters when constructing dynamic SQL statements. The following code shows how to use SqlParametersCollection with dynamic SQL:</P><PRE>using System.Data;<BR>using System.Data.SqlClient;</PRE><PRE>using (SqlConnection connection = new SqlConnection(connectionString))<BR>&#123;<BR>&nbsp; DataSet userDataset = new DataSet();<BR>&nbsp; SqlDataAdapter myDataAdapter = new SqlDataAdapter(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SELECT au_lname, au_fname FROM Authors WHERE au_id = &#64;au_id", <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp; myCommand.SelectCommand.Parameters.Add("&#64;au_id", SqlDbType.VarChar, 11);<BR>&nbsp; myCommand.SelectCommand.Parameters&#91;"&#64;au_id"&#93;.Value = AuthId.Text;<BR>&nbsp; myDataAdapter.Fill(userDataset);<BR>&#125;</PRE></LI></OL><H1>Problem Example</H1><P>An ASP.NET book purchasing application has a query interface that allows book titles and authors to be de retrieved by submitting an ISBN. The appllication developer's writes a SQL query&nbsp;to accomplish this task:</P><PRE>string SQLstr = "SELECT book_name, author_name FROM book WHERE book_ISBN = '" &#43; ISBN.Text &#43; "'";</PRE><P>The&nbsp;ISBN input is from a textfield in the&nbsp;web&nbsp;form which is used to directly generate&nbsp;the SQL statement. For example:</P><PRE>SELECT book_name, author_name FROM book WHERE book_ISBN = '0321194330'</PRE><P>Consider what happens when a user types the following string in the&nbsp;ISBN text box, which is expecting an ISBN in the form nnnnnnnnnn:</P><PRE>' ; DROP DATABASE pubs&nbsp; --<BR>&nbsp; </PRE><P>The code inserts the user's malicious input and generates the following query.</P><PRE>SELECT book_name, author_name FROM book WHERE book_ISBN = ''; DROP DATABASE pubs --'&nbsp; </PRE><P>In this case, the ' (single quotation mark) character that starts the rogue input terminates the current string literal in the SQL statement. The ; (semicolon) character tells SQL that this is the end of the current statement, which is then followed by the following malicious SQL code. Finally, the -- (double dash) sequence of characters is a SQL comment that tells SQL to ignore the rest of the text. In this case, SQL ignores the closing ' (single quotation mark) character, which would otherwise cause a SQL parser error.</P><H1>Solution Example</H1><P>An ASP.NET book purchasing application has a query interface that allows book titles and authors to be de retrieved by submitting an ISBN. The appllication developer's writes a SQL query&nbsp;to accomplish this task:</P><PRE>string SQLstr = "book_name, author_name FROM book WHERE book_ISBN = '" &#43; ISBN.Text &#43; "'";</PRE><P>The ISBN input is from a textfield in the&nbsp;web&nbsp;form which is used to directly generate&nbsp;the SQL statement. For example:</P><PRE>SELECTbook_name, author_name FROM book WHERE book_ISBN = '0321194330'</PRE><P>The&nbsp;SQL&nbsp;statement can be made safer by re-writing it as a parameterized, stored procedure:</P><PRE>using System.Data;<BR>using System.Data.SqlClient;</PRE><PRE>using (SqlConnection connection = new SqlConnection(connectionString))<BR>&#123;<BR>&nbsp; DataSet userDataset = new DataSet();<BR>&nbsp; SqlDataAdapter myDataAdapter = new SqlDataAdapter(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "'0321194330'= &#64;isbn",&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp; myCommand.SelectCommand.Parameters.Add("&#64;isbn", SqlDbType.VarChar, 11);<BR>&nbsp; myCommand.SelectCommand.Parameters&#91;"&#64;isbn"&#93;.Value = ISBN.Text;<BR>&nbsp; myDataAdapter.Fill(userDataset);<BR>&#125;</PRE><P>The SQL query statement&nbsp;is constructed similarly to&nbsp;the&nbsp;first SQL statement, except that the&nbsp;ISBN column selection criteria is represented as a placeholder rather than directly concatenated into the SQL query. The next two lines specify the variable type, the expected length, and the&nbsp;value of the&nbsp;ISBN field used in this particular query.&nbsp; This protects against SQL injection attacks because &#64;isbn is specified as a VarChar, which means it can't possibly be an executable SQL statement.&nbsp;Consequently, it will&nbsp;be interpreted by the database driver as a&nbsp;String literal.&nbsp;&nbsp;</P><P>It is important to note that while parameterized, stored procedures will help reduce the risk of SQL injection, there are other script injection vulnerabilities that will be possible. For more information see&nbsp;the related guideline, "Validate Untrusted Input Passed to Data Access Methods". </P><H1>Related Items</H1><UL><LI><A href="ruledisplay:fab1733c-61d7-46a8-88c6-2617a643c0d9">Use Least Privileged Accounts for Database Access</A> <LI><A href="ruledisplay:4be4ed09-ed2f-4f05-9e63-e20708807542">Use Type Safe SQL Parameters when Constructing SQL Queries</A> <LI><A href="ruledisplay:75fce1f7-10d9-430e-b7ab-ce2b73d9f2bc">Validate Untrusted Input Passed to Data Access Methods</A></LI></UL><HR><P>Adapted from Microsoft patterns &amp; practices guidance. </P>
]]></content></guidanceItem>