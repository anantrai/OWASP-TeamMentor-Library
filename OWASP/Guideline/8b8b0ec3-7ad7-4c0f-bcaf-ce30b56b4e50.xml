<?xml version="1.0" encoding="utf-8"?><guidanceItem id="8b8b0ec3-7ad7-4c0f-bcaf-ce30b56b4e50" type="guideline" title="Assume All Input Is Malicious" cssFile="guidance.css" Date="2011-01-20T03:20:01.90625Z" Author="" Category="Input and Data Validation" filePath="..\Libraries\OWASP\Guideline\8b8b0ec3-7ad7-4c0f-bcaf-ce30b56b4e50.xml" Priority="J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan" Rule_Type="Design" Source="OWASP" Status="" Technology=" Any" Topic="Security" Type="Guideline" xmlns="urn:microsoft:guidanceexplorer:guidanceItem"><content><![CDATA[<H1>Applies to</H1><UL><LI>Web Application</LI></UL><H1>What to Do</H1><P>Applications should assume that all of their input is malicious, and take action accordingly.&nbsp; Input should&nbsp;be validated and either rejected or sanitized immediately, carefully quarantined during use, and encoded appropriately on output.</P><H1>Why</H1><P>Malicious input is the single largest cause of vulnerabilities in web applications, and in the most general sense, is the root cause of almost every issue.&nbsp; The only way to ensure safety is by a defense in depth, default deny policy that starts with the fundamental supposition that all input is malicious until proven otherwise. For example, if you call an external Web service that returns strings, how do you know that malicious commands are not present? Also, if several applications write to a shared database, when you read data, how do you know whether it is safe?</P><H1>When</H1><P>All applications should assume that all their input is malicious.</P><H1>How</H1><P>Getting input validation correct is tricky; there's a reason that it's the number one security problem for web applications.&nbsp; However, when approached systematically, it's not too hard of a&nbsp;problem to solve.&nbsp; Follow these steps:</P><H2>1. Determine all inputs</H2><P>The first step is to determine all the things in the application which can be controlled by the user.&nbsp; There are some surprises here -- a lot of the variables in a normal HTTP server environment are actually taken from the user's request, so make sure you know exactly where everything is coming from.&nbsp; It's a good idea to leave a brief comment in the code where the input comes in mentioning where it comes from (if it isn't obvious from context), the expected format, and where it's validated (again, if it isn't obvious).</P><H2>2. Determine all trusted data stores</H2><P>&nbsp;Every application has at least one, usually multiple data stores.&nbsp; It's important to know when a data store can be trusted.&nbsp; The guideline here is simple; if the system in question is the only input into the data store, then you can rely on the semantics enforced by your input validation routines to apply to all data found in the store.&nbsp; If other applications access the data store, then you can't.&nbsp; While it is possible to check the semantics of every validation routine in every other system that accesses the data store, it's simpler and safer to assume that the data store is untrusted, and treat it as a potential source of malicious data, validating all input from it as you would any other input.</P><H2>3. Determine all crossover points</H2><P>Crossover points are one of the places where malicious input becomes a bug.&nbsp; They're not necessarily places where output occurs; in fact, they'll often occur many layers further in than that in large applications.&nbsp; A crossover point is anywhere where user input is included textually in some larger body of command text, or where a security-relevant decision is made based on it.&nbsp; A good example of a crossover point is a dynamic SQL query.&nbsp; The risk here is of the user input crossing over into the associated command data, allowing an attacker to execute commands.&nbsp; Xpath and other XML injections are another example here.&nbsp; The worst case here is when user input is evaluated by a languages built-in "eval" command or something similar -- these commands should never be used, even with values that look safe, because of the risks associated.</P><P>Once the crossover points are found, all inputs should be traced back to make sure that they've been validated appropriately beforehand, and a comment again stating the format, source, and validation point should be made.&nbsp;&nbsp;All crossover points have, depending on the technology involved, different sets of safe characters.&nbsp; Using the whitelist approach described below, the safe set of characters for that crossover point should be compared against what the validator will allow through; the allowed characters must be a subset of the safe ones.</P><P>Whenever possible, steps should be taken to remove crossover points entirely.&nbsp; Switching from dynamic SQL to stored procedures with bound parameters removes an entire category of crossover points from the system, and greatly reduces risk to an entire class of attacks.&nbsp; Similar things can be done with other types of crossovers.</P><H2>4. Determine all outputs</H2><P>The last point of concern is the list of outputs from the system.&nbsp; This will likely have a certain amount of overlap with the list of crossover points, which is fine.&nbsp; Again, we need to determine the allowable format for each output, and look at where the incoming data is being validated.&nbsp; If there's any question of whether the data may contain dangerous characters, it should be encoded in a manner appropriate to the specific output.&nbsp; There are more output contexts than one might thing; the contents of HTML attributes, the tags themselves, free text between the tags, and javascript strings all have different safe sets of characters (and a different encoding, in the last case).&nbsp; Comments on the input source, format, validation point, and encoding point&nbsp;are also useful here.</P><H2>5. Build a centralized validation module</H2><P>One of the biggest dangers of implementing input validation is inconsistent validation; an attack may be caught on one data path, but not on another.&nbsp; An attacker will try all of them, however.&nbsp; The way to solve this problem is to have a single point of responsibility for input validation.&nbsp; Where this is depends on the design.&nbsp; If every piece of input is an object, then it may be appropriate to have the object constructs and setters perform the validation for that object's input.&nbsp; In a less strictly OO system, a single module with methods for each different input format may be more appropriate.</P><P>Which ever method is chosen, the input validation routine for a specific data type should be as strict as possible.&nbsp; For example, when validating a US zip code, allow either 5 or 9 numbers, and nothing else.&nbsp; If you're dealing with international postal codes, either validate them seperately with a looser format that also allows letters, or build a more complex validator that understands the postal codes of each nation, if you need to ensure a higher level of integrity.</P><H2>6. Build a centralized encoding module</H2><P>In an ideal world, all encoding routines would be done via the same libraries which are used to create output.&nbsp; While many HTML control libraries attempt this, none of them take the whitelist approach.&nbsp; Instead, they try to guess which characters might be harmful, a list which is categorically incomplete.&nbsp; Unless you want to build a new output library (which might be an option on a large enough application), you should build a set of data encoders for each ouput context which you have.&nbsp; These encoders should be used as close as possible to the actual point of output; this minimizes the chance of an alternate data path skipping the encoding, and ensures that the developer knows exactly what context the output is being used in.&nbsp; Avoid the temptation to store encoded data, because even if it is initially only used in the context you encoded it for, this may change over time.</P><H2>7. Ensure that all paths through the system preserve validation</H2><P>Once the validation system is complete, all the paths that data takes through the system should be checked to ensure that they preserve the validation properties that are expected.&nbsp; Input which is sent round-trip through a client or another system must be re-validated, unless a cryptographic signature is used to ensure that it has not been tampered with.&nbsp; Validation which occurs on an untrusted system must also be repeated.&nbsp; Client-side validation in javascript is a nice UI touch, but it is trivially circumvented as&nbsp; a security measure.</P><H1>Problem Example</H1><P>A suite of web applications on an e-commerce site share a common back-end database.&nbsp; The largest application is&nbsp;the&nbsp;order entry system and shopping cart.&nbsp; This was the first application built, and was designed with the assumption that the database was trusted.&nbsp; Later, a lightweight app to allow users to quickly check stock levels was built.&nbsp; Because it was a small "read-only" use of the database, input validation was not built into the application.&nbsp; The application contained a SQL injection, allowing an attacker to alter the database in such a way that they could&nbsp;inject javascript into pages which displayed the shopping cart application, allowing them to steal user's passwords.&nbsp;</P><H1>Solution Example</H1><P>A suite of web applications on an e-commerce site share a common back-end database.&nbsp; The largest application is&nbsp;the&nbsp;order entry system and shopping cart.&nbsp; This was the first application built, and was designed with the assumption that the database was trusted.&nbsp; Later, a lightweight app to allow users to quickly check stock levels was built.&nbsp;&nbsp;When the new application was added, the developers realized that the database could no longer be treated as a trusted data store, and added code to the main application to perform data validation on input from the database.&nbsp;&nbsp;&nbsp;Because the new application was a small "read-only" use of the database, the input validation routines written were not properly checked.&nbsp; When an attacker found a SQL injection via the new application and altered the back-end database, they were unable to make that attack chain through to the main application.&nbsp; Furthermore, the logging performed by the main application's data validation routines altered the operations group to the problem, allowing them to fix the smaller application.</P><H1>Additional Resources</H1><UL><LI>For more information see, "Chapter 4 - Design Guidelines for Secure Web Applications" at <A href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</A></LI></UL><HR><P>Adapted from Microsoft patterns &amp; practices guidance.</P>]]></content></guidanceItem>